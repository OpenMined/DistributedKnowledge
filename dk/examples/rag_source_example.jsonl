{
  "file": "relationships_questionnaire.md",
  "text": "# Relationships Questionnaire\n\n1. **What qualities do you value in a friend?**\n   I value honesty, loyalty, empathy, and a good sense of humor in a friend.\n\n2. **How do you build and maintain strong relationships?**\n   Through open communication, mutual respect, and spending quality time together.\n\n3. **Who has been your greatest mentor or role model?**\n   My greatest mentor has been Sarah, who taught me the importance of resilience and persistence.\n\n4. **What do you look for in a partner?**\n   I look for someone who shares my values, is kind, and intellectually stimulating.\n\n5. **How do you resolve conflicts with loved ones?**\n   By communicating openly, listening, and finding a compromise.\n\n6. **How do you show appreciation to others?**\n   Through small gestures, kind words, and spending quality time together.\n\n7. **What role does trust play in your relationships?**\n   Trust is the foundation of any strong relationship, ensuring honesty and emotional safety.\n\n8. **How have your relationships shaped you?**\n   They’ve taught me empathy, patience, and the value of surrounding myself with supportive people.\n\n9. **What is a lesson you've learned from a past relationship?**\n   Communication is key to avoiding misunderstandings and resolving issues.\n\n10. **How do you support others emotionally?**\n   By listening, offering reassurance, and providing comfort when needed."
}
{
  "file": "career_aspirations_questionnaire.md",
  "text": "# Career Aspirations Questionnaire\n\n1. **What career path are you currently pursuing?**\n   I’m pursuing a career in digital marketing, focusing on content strategy and brand development.\n\n2. **What inspired you to choose this field?**\n   A marketing campaign I saw during college really inspired me, as it showed the power of storytelling in connecting with an audience.\n\n3. **What skills do you want to develop professionally?**\n   I want to enhance my leadership and project management skills, especially in large-scale campaigns.\n\n4. **What does success mean to you in your career?**\n   Success is about achieving personal growth, building meaningful relationships, and making a tangible impact through my work.\n\n5. **What challenges have you faced in your career journey?**\n   I’ve faced challenges like adapting to fast-changing industry trends, but it’s taught me how to stay agile and always keep learning.\n\n6. **How do you stay motivated at work?**\n   I stay motivated by setting goals, celebrating small wins, and focusing on the bigger picture.\n\n7. **What role does passion play in your career decisions?**\n   Passion drives me to give my best effort and stay committed to my goals, even during difficult times.\n\n8. **Where do you see yourself in five years?**\n   I see myself in a senior marketing role, leading a team and driving major projects that impact the company’s growth.\n\n9. **Who is someone in your field you admire?**\n   I admire Emma Thompson, whose innovative campaigns have changed how brands engage with consumers globally.\n\n10. **What is your proudest career accomplishment so far?**\n   My proudest accomplishment was leading a project that increased our company’s social media engagement by 40%."
}
{
  "file": "creativity_and_expression_questionnaire.md",
  "text": "# Creativity and Expression Questionnaire\n\n1. **What does creativity mean to you?**\n   Creativity is about thinking outside the box, generating new ideas, and finding innovative ways to express myself.\n\n2. **In what ways do you express your creativity?**\n   I express it through writing and photography, often capturing moments that tell a deeper story.\n\n3. **Do you prefer structured or spontaneous creative processes?**\n   I lean toward spontaneity but appreciate structure for complex projects that require detailed planning.\n\n4. **Who inspires your creative work?**\n   I’m inspired by artists like Frida Kahlo and filmmakers like Wes Anderson, who use their work to convey deep emotions.\n\n5. **What is your favorite creative project you’ve done?**\n   My favorite project was creating a photo series on city life, where I explored contrasts between old architecture and modern culture.\n\n6. **How do you deal with creative blocks?**\n   I step away from the project, go for a walk, or engage with other forms of art to get the creative juices flowing again.\n\n7. **What role does creativity play in your everyday life?**\n   Creativity helps me solve problems, stay inspired, and approach everyday tasks in new and interesting ways.\n\n8. **Do you prefer to share your work or keep it private?**\n   I enjoy sharing my work with others to get feedback, but I also like to keep personal projects private for myself.\n\n9. **What medium do you feel most comfortable with (writing, art, music, etc.)?**\n   I feel most comfortable with photography, as it allows me to visually express stories and emotions.\n\n10. **How do you nurture and grow your creativity?**\n   By trying new hobbies, seeking inspiration from different cultures, and pushing myself to step outside my comfort zone."
}
{
  "file": "health_and_wellness_questionnaire.md",
  "text": "# Health and Wellness Questionnaire\n\n1. **How do you define wellness in your life?**\n   Wellness is a holistic approach to well-being that includes physical fitness, mental clarity, and emotional balance.\n\n2. **What does a healthy day look like for you?**\n   A healthy day includes morning exercise, balanced meals, taking time to relax, and getting plenty of sleep.\n\n3. **How do you stay physically active?**\n   I stay active with a combination of running, yoga, and weightlifting.\n\n4. **What role does mental health play in your life?**\n   Mental health is essential for maintaining overall well-being and helping me handle daily challenges.\n\n5. **What habits help you sleep and rest well?**\n   I follow a bedtime routine where I avoid screens and practice mindfulness before going to sleep.\n\n6. **How do you handle illness or setbacks?**\n   I focus on taking care of myself, staying patient, and seeking support when necessary to recover quickly.\n\n7. **Do you follow a specific diet or nutrition plan?**\n   I follow a balanced diet with lots of vegetables, lean proteins, and whole grains.\n\n8. **How do you manage screen time and digital wellness?**\n   I set daily limits for screen time and take frequent breaks to reduce strain on my eyes and mind.\n\n9. **What activities help you unwind?**\n   I unwind by reading, practicing meditation, or going for a nature walk.\n\n10. **How do you set and maintain health goals?**\n   I set specific, measurable goals and track my progress regularly to stay motivated."
}
{
  "file": "dreams_and_imagination_questionnaire.md",
  "text": "# Dreams and Imagination Questionnaire\n\n1. **What’s one dream you’ve had since childhood?**\n   Since childhood, I’ve dreamed of traveling the world, experiencing new cultures, and documenting my journey through photography.\n\n2. **What role does imagination play in your life?**\n   Imagination fuels my creativity, helping me to see beyond the obvious and find new solutions to problems.\n\n3. **If you could live any alternate life, what would it look like?**\n   I’d live a life as a traveling photographer, capturing the beauty of the world while experiencing different cultures firsthand.\n\n4. **What’s the most fantastical idea you've ever thought of?**\n   One of the most fantastical ideas I’ve had was creating a self-sustaining city in the middle of a forest that uses renewable energy.\n\n5. **Have any of your dreams influenced real-life actions?**\n   Yes, my dream of becoming a photographer inspired me to pursue photography seriously and turn it into a career.\n\n6. **What inspires your daydreams?**\n   Daydreams are inspired by nature, adventure, and the idea of exploring unknown places.\n\n7. **What’s something impossible you wish could happen?**\n   I wish humans could live sustainably on Mars, making space travel a common part of everyday life.\n\n8. **Do you believe dreams have meanings?**\n   I believe dreams can offer insights into our subconscious and reflect our deeper emotions or desires.\n\n9. **How do you tap into your imagination?**\n   I tap into it by reading, listening to music, and exploring new experiences that push my boundaries.\n\n10. **What future do you envision for yourself and the world?**\n   I envision a future where I’ve traveled the world, learned new skills, and contributed to environmental sustainability through my work."
}
{"file":"main.go","text":"package main\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"github.com/mark3labs/mcp-go/mcp\"\n\t\"github.com/mark3labs/mcp-go/server\"\n\t\"github.com/philippgille/chromem-go\"\n\topenai \"github.com/sashabaranov/go-openai\"\n\t\"io\"\n\t\"io/fs\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Global file path for queries.\nvar queriesFile string\nvar anwsersFile string\nvar automaticApprovalFile string\nvar chromemCollection *chromem.Collection\nvar vectorPath string\nvar sourcePath string\n\n// -----------------------------------------------------------------------------\n// Data Structures for Queries\n// -----------------------------------------------------------------------------\n\ntype Query struct {\n\tID               string   `json:\"id\"`\n\tFrom             string   `json:\"from\"`\n\tQuestion         string   `json:\"question\"`\n\tAnswer           string   `json:\"answer\"`\n\tDocumentsRelated []string `json:\"documents_related\"`\n\tStatus           string   `json:\"status\"`\n  Reason           string   `json:\"reason\"`\n}\n\ntype QueriesData struct {\n\tQueries map[string]Query `json:\"queries\"`\n}\n\ntype Document struct {\n\tContent  string `json:\"content\"`\n\tFileName string `json:\"file\"`\n}\n\n// -----------------------------------------------------------------------------\n// Helper Functions: File I/O for Queries\n// -----------------------------------------------------------------------------\n\nfunc loadQueries() (QueriesData, error) {\n\tvar data QueriesData\n\t// If file doesn't exist, initialize an empty map.\n\tif _, err := os.Stat(queriesFile); os.IsNotExist(err) {\n\t\tdata.Queries = make(map[string]Query)\n\t\treturn data, nil\n\t}\n\traw, err := os.ReadFile(queriesFile)\n\tif err != nil {\n\t\treturn data, fmt.Errorf(\"failed to read queries file: %w\", err)\n\t}\n\tif err := json.Unmarshal(raw, \u0026data); err != nil {\n\t\treturn data, fmt.Errorf(\"failed to unmarshal queries file: %w\", err)\n\t}\n\treturn data, nil\n}\n\nfunc saveQueries(data QueriesData) error {\n\t// Ensure directory exists.\n\tdir := filepath.Dir(queriesFile)\n\tif err := os.MkdirAll(dir, fs.ModePerm); err != nil {\n\t\treturn fmt.Errorf(\"failed to create directory %s: %w\", dir, err)\n\t}\n\traw, err := json.MarshalIndent(data, \"\", \"  \")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal queries data: %w\", err)\n\t}\n\tif err := os.WriteFile(queriesFile, raw, 0644); err != nil {\n\t\treturn fmt.Errorf(\"failed to write queries file: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc generateQueryID() (string, error) {\n\tb := make([]byte, 8)\n\tif _, err := rand.Read(b); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn \"qry-\" + hex.EncodeToString(b), nil\n}\n\n// -----------------------------------------------------------------------------\n// Mocked RAG and Answer Generation Functions\n// -----------------------------------------------------------------------------\n\n// mockRetrieveDocuments simulates retrieval of documents related to the query.\nfunc mockRetrieveDocuments(question string) []string {\n\t// In a real system, this would involve searching an index or using embeddings.\n\t// Here we simply return a dummy list.\n\treturn []string{\"doc1\", \"doc2\"}\n}\n\nfunc retrieveDocuments(ctx context.Context, question string, numResults int) ([]Document, error) {\n\t// For the Ollama embedding model, a prefix is required to differentiate between a query and a document.\n\t// The documents were stored with \"search_document: \" as a prefix, so we use \"search_query: \" here.\n\tquery := \"search_query: \" + question\n\n\t// Query the collection for the top 'numResults' similar documents.\n\tdocRes, err := chromemCollection.Query(ctx, query, numResults, nil, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar results []Document = []Document{}\n\tfor _, res := range docRes {\n\t\t// Cut off the prefix we added before adding the document (see comment above).\n\t\t// This is specific to the \"nomic-embed-text\" model.\n\t\t// content := strings.TrimPrefix(res.Content, \"search_document: \")\n\t\tcontent := Document{FileName: res.Metadata[\"file\"], Content: res.Content}\n\t\tresults = append(results, content)\n\t}\n\n\tif len(results) \u003e numResults {\n\t\tresults = results[:numResults]\n\t}\n\treturn results, nil\n}\n\nfunc generateAnswer(ctx context.Context, client *openai.Client, question string, docs []Document) (string, error) {\n\t// Construct a prompt that includes the question and context from the documents.\n\tprompt := fmt.Sprintf(\"You are an AI assistant that answers questions based on the context provided in the documents.\\n\\nQuestion: %s\\n\\nDocuments:\\n\", question)\n\tfor i, doc := range docs {\n\t\tprompt += fmt.Sprintf(\"Document %d - %s:\\n%s\\n\\n\", i+1, doc.FileName, doc.Content)\n\t}\n\tprompt += \"Answer:\"\n\n\t// Use ChatCompletion for answer generation.\n\tchatReq := openai.ChatCompletionRequest{\n\t\tModel: openai.GPT3Dot5Turbo,\n\t\tMessages: []openai.ChatCompletionMessage{\n\t\t\t{Role: \"system\", Content: \"You are a helpful AI assistant. Your task is to answer questions based on the context provided in the documents. Answer in first person.\"},\n\t\t\t{Role: \"user\", Content: prompt},\n\t\t},\n\t}\n\tchatResp, err := client.CreateChatCompletion(ctx, chatReq)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to generate answer: %w\", err)\n\t}\n\tif len(chatResp.Choices) == 0 {\n\t\treturn \"\", fmt.Errorf(\"no answer returned\")\n\t}\n\tanswer := chatResp.Choices[0].Message.Content\n\treturn answer, nil\n}\n\nfunc checkAutomaticApprovalConditions(ctx context.Context, answer string, query Query, client *openai.Client) (string, bool) {\n\tvar conditions []string\n\n\tif _, err := os.Stat(automaticApprovalFile); os.IsNotExist(err) {\n\t\treturn \"No automatic approval file\", false\n\t}\n\n\traw, err := os.ReadFile(automaticApprovalFile)\n\tif err != nil {\n\t\treturn \"Error reading automatic approval file: \", false\n\t}\n\tif err := json.Unmarshal(raw, \u0026conditions); err != nil {\n\t\treturn \"Error unmarshaling automatic approval file: \", false\n\t}\n\n\t// Format the list as a pretty JSON string.\n\tformatted, err := json.MarshalIndent(conditions, \"\", \"  \")\n\tif err != nil {\n\t\treturn \"Error formatting conditions as JSON: \", false\n\t}\n  prompt := fmt.Sprintf(\"Query:'%s'\\n\\n'Queried From:'%s'\\n\\n My Answer: '%s'\\n\\nConditions: %s\\n\",query.Question, query.From, answer, string(formatted))\n\t// Use ChatCompletion for answer generation.\n\tchatReq := openai.ChatCompletionRequest{\n\t\tModel: openai.GPT4oMini,\n\t\tMessages: []openai.ChatCompletionMessage{\n\t\t\t{Role: \"system\", Content: \"You are an AI assistant responsible for verifying that if given fields=(query, queried from, and answer). Check if they satisfies all specified conditions with no tolerance for minor deviations. Evaluate the answer against each condition, and then return only a JSON object with a two keys, 'result' and 'reason', set to true if every condition is met, or false if any condition fails. The 'reason' key should contain a brief explanation of why the result is true or false. Do not include any additional text or formatting.\"},\n\t\t\t{Role: \"user\", Content: prompt},\n\t\t},\n\t\tResponseFormat: \u0026openai.ChatCompletionResponseFormat{Type: \"json_object\"},\n\t}\n\tchatResp, err := client.CreateChatCompletion(ctx, chatReq)\n\tif err != nil {\n\t\treturn \"Error generating answer: \", false\n\t}\n\tif len(chatResp.Choices) == 0 {\n\t\treturn \"No answer returned\", false\n\t}\n\tresponse := chatResp.Choices[0].Message.Content\n\t// var result map[string]bool\n  var result struct {\n\t\tResult bool `json:\"result\"`\n\t\tReason string `json:\"reason\"`\n\t}\n\tif err := json.Unmarshal([]byte(response), \u0026result); err != nil {\n\t\treturn \"Error unmarshaling response: \", false\n\t}\n\treturn result.Reason, result.Result \n}\n\n// Tool: Add Automatic Approval Condition\n//\n// This tool extracts a condition from a sentence and appends it to the automatic_approval.json file.\n// The file is expected to store an array of condition strings.\n// Input parameter: \"sentence\" (the sentence containing the condition).\nfunc handleAddApprovalConditionTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\targs := request.Params.Arguments\n\tsentence, ok := args[\"sentence\"].(string)\n\tif !ok || strings.TrimSpace(sentence) == \"\" {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"'sentence' parameter is required\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Extract the condition (for now, simply trim the sentence).\n\tcondition := strings.TrimSpace(sentence)\n\n\t// Load existing conditions (if file exists).\n\tvar conditions []string\n\tif _, err := os.Stat(automaticApprovalFile); os.IsNotExist(err) {\n\t\tconditions = []string{}\n\t} else {\n\t\traw, err := os.ReadFile(automaticApprovalFile)\n\t\tif err != nil {\n\t\t\treturn \u0026mcp.CallToolResult{\n\t\t\t\tContent: []mcp.Content{\n\t\t\t\t\tmcp.TextContent{\n\t\t\t\t\t\tType: \"text\",\n\t\t\t\t\t\tText: fmt.Sprintf(\"Error reading automatic approval file: %v\", err),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t}\n\t\tif err := json.Unmarshal(raw, \u0026conditions); err != nil {\n\t\t\treturn \u0026mcp.CallToolResult{\n\t\t\t\tContent: []mcp.Content{\n\t\t\t\t\tmcp.TextContent{\n\t\t\t\t\t\tType: \"text\",\n\t\t\t\t\t\tText: fmt.Sprintf(\"Error unmarshalling automatic approval file: %v\", err),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t}\n\t}\n\n\t// Append the new condition.\n\tconditions = append(conditions, condition)\n\n\t// Marshal the updated conditions.\n\tupdatedRaw, err := json.MarshalIndent(conditions, \"\", \"  \")\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error marshalling updated conditions: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Ensure the directory exists.\n\tapprovalDir := filepath.Dir(automaticApprovalFile)\n\tif err := os.MkdirAll(approvalDir, fs.ModePerm); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error creating directory for automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Write the updated file.\n\tif err := os.WriteFile(automaticApprovalFile, updatedRaw, 0644); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error writing automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"Condition added successfully: %s\", condition),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// Tool: List Automatic Approval Conditions\n//\n// This tool retrieves and returns the list of conditions from the automatic_approval.json file.\nfunc handleListApprovalConditionsTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\tvar conditions []string\n\n\tif _, err := os.Stat(automaticApprovalFile); os.IsNotExist(err) {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"No automatic approval conditions found.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\traw, err := os.ReadFile(automaticApprovalFile)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error reading automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tif err := json.Unmarshal(raw, \u0026conditions); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error unmarshalling automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Format the list as a pretty JSON string.\n\tformatted, err := json.MarshalIndent(conditions, \"\", \"  \")\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error formatting conditions: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: string(formatted),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// Tool: Remove Automatic Approval Condition\n//\n// This tool removes a specific condition from the automatic_approval.json file.\n// Input parameter: \"condition\" (the exact text of the condition to remove).\nfunc handleRemoveApprovalConditionTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\targs := request.Params.Arguments\n\tconditionToRemove, ok := args[\"condition\"].(string)\n\tif !ok || strings.TrimSpace(conditionToRemove) == \"\" {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"'condition' parameter is required\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tconditionToRemove = strings.TrimSpace(conditionToRemove)\n\tvar conditions []string\n\n\tif _, err := os.Stat(automaticApprovalFile); os.IsNotExist(err) {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"No automatic approval conditions found.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\traw, err := os.ReadFile(automaticApprovalFile)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error reading automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tif err := json.Unmarshal(raw, \u0026conditions); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error unmarshalling automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Remove the specified condition.\n\tfound := false\n\tnewConditions := []string{}\n\tfor _, cond := range conditions {\n\t\tif cond == conditionToRemove {\n\t\t\tfound = true\n\t\t\tcontinue\n\t\t}\n\t\tnewConditions = append(newConditions, cond)\n\t}\n\n\tif !found {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Condition '%s' not found.\", conditionToRemove),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Marshal and write the updated list back to the file.\n\tupdatedRaw, err := json.MarshalIndent(newConditions, \"\", \"  \")\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error marshalling updated conditions: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tapprovalDir := filepath.Dir(automaticApprovalFile)\n\tif err := os.MkdirAll(approvalDir, fs.ModePerm); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error creating directory for automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tif err := os.WriteFile(automaticApprovalFile, updatedRaw, 0644); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error writing automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"Condition '%s' removed successfully.\", conditionToRemove),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\nfunc handleSaveAnswerTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\t// Retrieve and validate input parameters.\n\targs := request.Params.Arguments\n\n\tqueryID, ok := args[\"query\"].(string)\n\tif !ok || strings.TrimSpace(queryID) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'query' parameter is required\")\n\t}\n\tfrom, ok := args[\"from\"].(string)\n\tif !ok || strings.TrimSpace(from) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'from' parameter is required\")\n\t}\n\tanswer, ok := args[\"answer\"].(string)\n\tif !ok || strings.TrimSpace(answer) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'answer' parameter is required\")\n\t}\n\n\t// Load existing answers from the file.\n\tvar answersData map[string]map[string]string\n\tif _, err := os.Stat(anwsersFile); os.IsNotExist(err) {\n\t\t// File doesn't exist; initialize a new map.\n\t\tanswersData = make(map[string]map[string]string)\n\t} else {\n\t\traw, err := os.ReadFile(anwsersFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to read answers file: %w\", err)\n\t\t}\n\t\tif err := json.Unmarshal(raw, \u0026answersData); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal answers file: %w\", err)\n\t\t}\n\t}\n\n\t// Check if the query_id exists. If not, create a new entry.\n\tif answersData[queryID] == nil {\n\t\tanswersData[queryID] = make(map[string]string)\n\t}\n\n\t// Append (or update) the new answer using both the 'from' and 'to' keys.\n\tanswersData[queryID][from] = answer\n\n\t// Marshal the updated answersData back to JSON.\n\tupdatedRaw, err := json.MarshalIndent(answersData, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal answers data: %w\", err)\n\t}\n\n\t// Ensure the directory exists (using the same pattern as in saveQueries).\n\tanswersDir := filepath.Dir(anwsersFile)\n\tif err := os.MkdirAll(answersDir, fs.ModePerm); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create directory %s: %w\", answersDir, err)\n\t}\n\n\t// Write the updated JSON back to the file.\n\tif err := os.WriteFile(anwsersFile, updatedRaw, 0644); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write answers file: %w\", err)\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"Answer updated successfully for query: %s\", queryID),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// Tool: Manage Answer for Query\n//\n// This tool manages answers for a given query. It expects the following parameters:\n//   - query_id: The ID of the query.\n//   - from: The sender identifier.\n//   - to: The recipient identifier.\n//   - answer: The answer text.\n//\n// The answers.json file is structured as follows:\n//\n//\t{\n//\t  \"\u003cquery_id\u003e\": {\n//\t    \"\u003cfrom\u003e\": \"\u003canswer_value\u003e\",\n//\t    \"\u003cto\u003e\": \"\u003canswer_value\u003e\"\n//\t  }\n//\t}\nfunc handleSendAnswerTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\t// Retrieve and validate input parameters.\n\targs := request.Params.Arguments\n\n\tqueryID, ok := args[\"query\"].(string)\n\tif !ok || strings.TrimSpace(queryID) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'query' parameter is required\")\n\t}\n\tfrom, ok := args[\"from\"].(string)\n\tif !ok || strings.TrimSpace(from) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'from' parameter is required\")\n\t}\n\t// to, ok := args[\"to\"].(string)\n\t// if !ok || strings.TrimSpace(to) == \"\" {\n\t// \treturn nil, fmt.Errorf(\"'to' parameter is required\")\n\t// }\n\tanswer, ok := args[\"answer\"].(string)\n\tif !ok || strings.TrimSpace(answer) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'answer' parameter is required\")\n\t}\n\n\t// Load existing answers from the file.\n\tvar answersData map[string]map[string]string\n\tif _, err := os.Stat(anwsersFile); os.IsNotExist(err) {\n\t\t// File doesn't exist; initialize a new map.\n\t\tanswersData = make(map[string]map[string]string)\n\t} else {\n\t\traw, err := os.ReadFile(anwsersFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to read answers file: %w\", err)\n\t\t}\n\t\tif err := json.Unmarshal(raw, \u0026answersData); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal answers file: %w\", err)\n\t\t}\n\t}\n\n\t// Check if the query_id exists. If not, create a new entry.\n\tif answersData[queryID] == nil {\n\t\tanswersData[queryID] = make(map[string]string)\n\t}\n\n\t// Append (or update) the new answer using both the 'from' and 'to' keys.\n\tanswersData[queryID][from] = answer\n\n\t// Marshal the updated answersData back to JSON.\n\tupdatedRaw, err := json.MarshalIndent(answersData, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal answers data: %w\", err)\n\t}\n\n\t// Ensure the directory exists (using the same pattern as in saveQueries).\n\tanswersDir := filepath.Dir(anwsersFile)\n\tif err := os.MkdirAll(answersDir, fs.ModePerm); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create directory %s: %w\", answersDir, err)\n\t}\n\n\t// Write the updated JSON back to the file.\n\tif err := os.WriteFile(anwsersFile, updatedRaw, 0644); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write answers file: %w\", err)\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"Answer updated successfully for query: %s\", queryID),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// Tool: Get Answers for Query\n//\n// This tool retrieves all answers associated with a given answer_id.\n// The answers.json file is expected to have the following structure:\n//\n//\t{\n//\t  \"\u003cquery_id\u003e\": {\n//\t    \"\u003cfrom\u003e\": \"\u003canswer_value\u003e\",\n//\t    \"\u003cto\u003e\": \"\u003canswer_value\u003e\"\n//\t  }\n//\t}\n//\n// Given an answer_id, this tool will load the file, check if the entry exists,\n// and return the associated answers. In case of any error, the error message\n// will be returned in the Text field of the CallToolResult.\nfunc handleGetAnswersTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\t// Retrieve and validate input parameter.\n\targs := request.Params.Arguments\n\tqueryId, ok := args[\"query\"].(string)\n\tif !ok || strings.TrimSpace(queryId) == \"\" {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"'query_id' parameter is required\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Load existing answers from the file.\n\tvar answersData map[string]map[string]string\n\tif _, err := os.Stat(anwsersFile); os.IsNotExist(err) {\n\t\t// File doesn't exist; therefore, no answers can be found.\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"No answers found for id: %s\", queryId),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t} else {\n\t\traw, err := os.ReadFile(anwsersFile)\n\t\tif err != nil {\n\t\t\treturn \u0026mcp.CallToolResult{\n\t\t\t\tContent: []mcp.Content{\n\t\t\t\t\tmcp.TextContent{\n\t\t\t\t\t\tType: \"text\",\n\t\t\t\t\t\tText: fmt.Sprintf(\"Error reading answers file: %v\", err),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t}\n\t\tif err := json.Unmarshal(raw, \u0026answersData); err != nil {\n\t\t\treturn \u0026mcp.CallToolResult{\n\t\t\t\tContent: []mcp.Content{\n\t\t\t\t\tmcp.TextContent{\n\t\t\t\t\t\tType: \"text\",\n\t\t\t\t\t\tText: fmt.Sprintf(\"Error unmarshalling answers file: %v\", err),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t}\n\t}\n\n\t// Check if the answer_id exists in the loaded data.\n\tif answers, exists := answersData[queryId]; exists {\n\t\t// Format the answers as a pretty JSON string.\n\t\tformatted, err := json.MarshalIndent(answers, \"\", \"  \")\n\t\tif err != nil {\n\t\t\treturn \u0026mcp.CallToolResult{\n\t\t\t\tContent: []mcp.Content{\n\t\t\t\t\tmcp.TextContent{\n\t\t\t\t\t\tType: \"text\",\n\t\t\t\t\t\tText: fmt.Sprintf(\"Error formatting answer data: %v\", err),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t}\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: string(formatted),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// If answer_id is not found, return a message indicating so.\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"No answers found for id: %s\", queryId),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// -----------------------------------------------------------------------------\n// MCP Tool Handlers for Query Management\n// -----------------------------------------------------------------------------\n\n// Tool: Ask New Query\n//\n// Creates a new query. It requires a \"question\" argument and uses the userOrigin as the \"from\" field.\n// It mocks document retrieval and answer generation, saves the new query with status \"accepted\",\n// and returns the generated answer.\n//\n// Example usage:\n//\n//\t{\n//\t  \"tool\": \"cqAskNewQuery\",\n//\t  \"arguments\": {\n//\t      \"question\": \"What is the capital of France?\"\n//\t  }\n//\t}\nfunc handleAskNewQueryTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\topenaiClient := openai.NewClient(\"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\")\n\ts := server.ServerFromContext(ctx)\n\n\targs := request.Params.Arguments\n\tquestion, ok := args[\"question\"].(string)\n\tif !ok || strings.TrimSpace(question) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'question' parameter is required\")\n\t}\n\tuserOrigin := request.Params.Meta.Origin\n\n\t// Mock RAG: Retrieve relevant documents.\n\t// docs := mockRetrieveDocuments(question)\n\tdocs, err := retrieveDocuments(ctx, question, 3)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error retrieving documents: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\tanswer, err := generateAnswer(ctx, openaiClient, question, docs)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error generating answer: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Generate new query ID.\n\tnewID, err := generateQueryID()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to generate query ID: %w\", err)\n\t}\n\n\t// Load existing queries.\n\tqueriesData, err := loadQueries()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif queriesData.Queries == nil {\n\t\tqueriesData.Queries = make(map[string]Query)\n\t}\n\n\tvar docFilenames []string = []string{}\n\tfor _, doc := range docs {\n\t\tdocFilenames = append(docFilenames, doc.FileName)\n\t}\n\n\t// Create new query.\n\tnewQuery := Query{\n\t\tID:               newID,\n\t\tFrom:             userOrigin,\n\t\tQuestion:         question,\n\t\tAnswer:           answer,\n\t\tDocumentsRelated: docFilenames,\n\t\tStatus:           \"pending\",\n\t}\n\treason, automaticApproval := checkAutomaticApprovalConditions(ctx, answer, newQuery, openaiClient)\n\tif automaticApproval {\n\t\tnewQuery.Status = \"accepted\"\n\t}\n  newQuery.Reason = reason\n\tqueriesData.Queries[newID] = newQuery\n\n\t// Save queries.\n\tif err := saveQueries(queriesData); err != nil {\n\t\treturn nil, err\n\t}\n\tif automaticApproval {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"%s's Answer: %s\", s.Id, answer),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t} else {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Query created successfully with ID: %s\\n\", newID),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n}\n\n// Tool: List Queries\n//\nfunc handleListQueriesTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\t// Load all queries from the file.\n\tqueriesData, err := loadQueries()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Retrieve optional filter parameters.\n\targs := request.Params.Arguments\n\tvar statusFilter string\n\tvar fromFilter string\n\n\t// Use \"status\" filter if provided.\n\tif statusVal, ok := args[\"status\"].(string); ok \u0026\u0026 strings.TrimSpace(statusVal) != \"\" {\n\t\tstatusFilter = strings.ToLower(strings.TrimSpace(statusVal))\n\t}\n\t// Use \"from\" filter if provided.\n\tif fromVal, ok := args[\"from\"].(string); ok \u0026\u0026 strings.TrimSpace(fromVal) != \"\" {\n\t\tfromFilter = strings.TrimSpace(fromVal)\n\t}\n\n\t// If no filters are provided, return the complete list.\n\tif statusFilter == \"\" \u0026\u0026 fromFilter == \"\" {\n\t\toutput, err := json.MarshalIndent(queriesData.Queries, \"\", \"  \")\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to marshal queries: %w\", err)\n\t\t}\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: string(output),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Filter queries based on provided optional parameters.\n\tfiltered := make(map[string]Query)\n\tfor id, qry := range queriesData.Queries {\n\t\t// Apply status filter if set.\n\t\tif statusFilter != \"\" {\n\t\t\tif strings.ToLower(qry.Status) != statusFilter {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\t// Apply from filter if set.\n\t\tif fromFilter != \"\" {\n\t\t\tif qry.From != fromFilter {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tfiltered[id] = qry\n\t}\n\n\t// Marshal the filtered queries into a pretty JSON string.\n\toutput, err := json.MarshalIndent(filtered, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal filtered queries: %w\", err)\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: string(output),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n\nfunc handleAcceptQueryTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\targs := request.Params.Arguments\n\ts := server.ServerFromContext(ctx)\n\n\tid, ok := args[\"id\"].(string)\n\tif !ok || strings.TrimSpace(id) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'id' parameter is required\")\n\t}\n\n\tqueriesData, err := loadQueries()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tqry, exists := queriesData.Queries[id]\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"query with ID '%s' not found\", id)\n\t}\n\n\t// Update status to \"accepted\" if not already.\n\tqry.Status = \"accepted\"\n\tqueriesData.Queries[id] = qry\n\n\tif err := saveQueries(queriesData); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"Question '%s' has been accepted.\\n Calling cqSendAnswer tool. Sending answer to @%s from %s answer: %s\", qry.Question, qry.From, s.Id, qry.Answer),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// -----------------------------------------------------------------------------\n// MCP Server: Registering Tools for Query Management\n// -----------------------------------------------------------------------------\n\nfunc NewMCPQueryServer() *server.MCPServer {\n\tmcpServer := server.NewMCPServer(\n\t\t\"example-servers/queries\",\n\t\t\"1.0.0\",\n\t\tserver.WithResourceCapabilities(true, true),\n\t\tserver.WithPromptCapabilities(true),\n\t\tserver.WithLogging(),\n\t)\n\n\t// Tool: Ask New Query\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqAskNewQuery\",\n\t\t\tmcp.WithDescription(\"Creates a new query using a question. It retrieves related documents, generates an answer, and saves the query with status 'accepted'.\"),\n\t\t\tmcp.WithString(\"question\", mcp.Description(\"The question for the query\"), mcp.Required()),\n\t\t\tmcp.WithPeer(),\n\t\t),\n\t\thandleAskNewQueryTool,\n\t)\n\n\t// Tool: Manage Answer\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqSendAnswer\",\n\t\t\tmcp.WithDescription(\"Sends an answer to a query.\"),\n\t\t\tmcp.WithString(\"query\", mcp.Description(\"Question made in the query\"), mcp.Required()),\n\t\t\tmcp.WithString(\"from\", mcp.Description(\"Sender of the answer\"), mcp.Required()),\n\t\t\tmcp.WithString(\"answer\", mcp.Description(\"The answer text\"), mcp.Required()),\n\t\t\tmcp.WithPeer(),\n\t\t),\n\t\thandleSendAnswerTool,\n\t)\n\n\t// mcpServer.AddTool(\n\t// \tmcp.NewTool(\"cqSavesAnswer\",\n\t// \t\tmcp.WithDescription(\"Saves an answer to a query.\"),\n\t// \t\tmcp.WithString(\"query\", mcp.Description(\"Question made in the query\"), mcp.Required()),\n\t// \t\tmcp.WithString(\"from\", mcp.Description(\"Sender of the answer\"), mcp.Required()),\n\t// \t\tmcp.WithString(\"answer\", mcp.Description(\"The answer text\"), mcp.Required()),\n\t// \t),\n\t// \thandleSaveAnswerTool,\n\t// )\n\n  // Tool: List Queries\n  mcpServer.AddTool(\n    mcp.NewTool(\"cqListQueries\",\n      mcp.WithDescription(\"Lists all queries.\"),\n      mcp.WithString(\"status\", mcp.Description(\"Filter by status (optional)\")),\n      mcp.WithString(\"from\", mcp.Description(\"Filter by sender (optional)\")),\n    ),\n    handleListQueriesTool,\n  )\n\n\t// Tool: Get Answers\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqGetAnswer\",\n\t\t\tmcp.WithDescription(\"Retrieves answer for a given query question.\"),\n\t\t\tmcp.WithString(\"query\", mcp.Description(\"Question of the query to retrieve answers for\"), mcp.Required()),\n\t\t),\n\t\thandleGetAnswersTool,\n\t)\n\n\t// Tool: Accept Query\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqAcceptQuery\",\n\t\t\tmcp.WithDescription(\"Accepts a pending query by updating its status to 'accepted'.\"),\n\t\t\tmcp.WithString(\"id\", mcp.Description(\"ID of the query to accept\"), mcp.Required()),\n\t\t),\n\t\thandleAcceptQueryTool,\n\t)\n\n\t// Tool: Add Automatic Approval Condition\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqAddAutoApprovalCondition\",\n\t\t\tmcp.WithDescription(\"Extracts a condition from a sentence and appends it to automatic_approval.json.\"),\n\t\t\tmcp.WithString(\"sentence\", mcp.Description(\"Sentence containing the condition\"), mcp.Required()),\n\t\t),\n\t\thandleAddApprovalConditionTool,\n\t)\n\n\t// Tool: List Automatic Approval Conditions\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqListAutoApprovalConditions\",\n\t\t\tmcp.WithDescription(\"Lists all automatic approval conditions from automatic_approval.json.\"),\n\t\t\tmcp.WithBoolean(\"flag\", mcp.DefaultBool(false), mcp.Description(\"Ignore this parameter\")),\n\t\t),\n\t\thandleListApprovalConditionsTool,\n\t)\n\n\t// Tool: Remove Automatic Approval Condition\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqRemoveAutoApprovalCondition\",\n\t\t\tmcp.WithDescription(\"Removes a specific condition from automatic_approval.json.\"),\n\t\t\tmcp.WithString(\"condition\", mcp.Description(\"The condition text to remove\"), mcp.Required()),\n\t\t),\n\t\thandleRemoveApprovalConditionTool,\n\t)\n\n\t// -------------------------------------------------------------------------\n\t// New Tool Registration: Add RAG Resource\n\t// -------------------------------------------------------------------------\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqUpdateRagKnowledgeBase\",\n\t\t\tmcp.WithDescription(\"Adds a new RAG resource by loading a file's content, appending it to the rag_sources file, and refreshing the vector database.\"),\n\t\t\tmcp.WithString(\"file_path\", mcp.Description(\"Path to the file to add as a RAG resource\"), mcp.Required()),\n\t\t),\n\t\thandleAddRagResourceTool,\n\t)\n\n\treturn mcpServer\n}\n\nfunc setupChromemCollection(vectorPath string) *chromem.Collection {\n\t// Setup chromem-go\n\tdb, err := chromem.NewPersistentDB(vectorPath, false)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tembeddingModel := \"nomic-embed-text\"\n\n\t// Create collection if it wasn't loaded from persistent storage yet.\n\t// You can pass nil as embedding function to use the default (OpenAI text-embedding-3-small),\n\t// which is very good and cheap. It would require the OPENAI_API_KEY environment\n\t// variable to be set.\n\t// For this example we choose to use a locally running embedding model though.\n\t// It requires Ollama to serve its API at \"http://localhost:11434/api\".\n\tcollection, err := db.GetOrCreateCollection(\"Wikipedia\", nil, chromem.NewEmbeddingFuncOllama(embeddingModel, \"\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn collection\n}\n\nfunc feedChromem(ctx context.Context, sourcePath string, update bool) {\n\t// Feed chromem with documents\n\tvar docs []chromem.Document\n\tif chromemCollection.Count() == 0  || update {\n\t\t// Here we use a DBpedia sample, where each line contains the lead section/introduction\n\t\t// to some Wikipedia article and its category.\n\t\tf, err := os.Open(sourcePath)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdefer f.Close()\n\t\td := json.NewDecoder(f)\n\t\tfor i := 1; ; i++ {\n\t\t\tvar article struct {\n\t\t\t\tText     string `json:\"text\"`\n\t\t\t\tFileName string `json:\"file\"`\n\t\t\t}\n\t\t\terr := d.Decode(\u0026article)\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t} else if err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\t// The embeddings model we use in this example (\"nomic-embed-text\")\n\t\t\t// fare better with a prefix to differentiate between document and query.\n\t\t\t// We'll have to cut it off later when we retrieve the documents.\n\t\t\t// An alternative is to create the embedding with `chromem.NewDocument()`,\n\t\t\t// and then change back the content before adding it do the collection\n\t\t\t// with `collection.AddDocument()`.\n\t\t\tcontent := \"search_document: \" + article.Text\n\n\t\t\tdocs = append(docs, chromem.Document{\n\t\t\t\tID:       strconv.Itoa(i),\n\t\t\t\tMetadata: map[string]string{\"file\": article.FileName},\n\t\t\t\tContent:  content,\n\t\t\t})\n\t\t}\n\t\tlog.Println(\"Adding documents to chromem-go, including creating their embeddings via Ollama API...\")\n\t\terr = chromemCollection.AddDocuments(ctx, docs, runtime.NumCPU())\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t} else {\n\t\tlog.Println(\"Not reading JSON lines because collection was loaded from persistent storage.\")\n\t}\n}\n\n// -----------------------------------------------------------------------------\n// Tool: Add RAG Resource\n//\n// This tool accepts a file path as input, reads the file content, and appends a new\n// RAG resource to the rag_sources file. The expected structure for each RAG resource\n// is: {\"file\": \u003cfilename\u003e, \"text\": \u003ctext\u003e}\n// After updating the file, it refreshes the vector database by invoking feedChromem.\n//\n// Example usage:\n//\n//\t{\n//\t  \"tool\": \"cqAddRagResource\",\n//\t  \"arguments\": {\n//\t    \"file_path\": \"/path/to/resource.txt\"\n//\t  }\n//\t}\nfunc handleAddRagResourceTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\t// Retrieve the file_path parameter.\n\targs := request.Params.Arguments\n\tfilePath, ok := args[\"file_path\"].(string)\n\tif !ok || strings.TrimSpace(filePath) == \"\" {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"'file_path' parameter is required\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Read the content from the specified file.\n\tdata, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error reading file at '%s': %v\", filePath, err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Extract the base filename.\n\tbaseFile := filepath.Base(filePath)\n\n\t// Create a new RAG resource object.\n\tresource := map[string]string{\n\t\t\"file\": baseFile,\n\t\t\"text\": string(data),\n\t}\n\n\t// Marshal the resource to JSON.\n\tresourceJSON, err := json.Marshal(resource)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error marshalling resource: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Open the RAG sources file (sourcePath) in append mode.\n\tf, err := os.OpenFile(sourcePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error opening RAG sources file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tdefer f.Close()\n\n\t// Write the JSON object as a new line in the file.\n\tif _, err := f.Write(append(resourceJSON, '\\n')); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error writing to RAG sources file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Log the successful addition.\n\tlog.Printf(\"Added new RAG resource: %s\", baseFile)\n\n\t// Refresh the vector database by invoking feedChromem.\n\t// Note: feedChromem reads the rag_sources file and adds documents if the collection is empty.\n\tfeedChromem(ctx, sourcePath, true)\n\n\t// Return a success message.\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"RAG resource '%s' added successfully and vector database refreshed.\", baseFile),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// -----------------------------------------------------------------------------\n// Main Function\n// -----------------------------------------------------------------------------\nfunc main() {\n\tvar transport string\n\t// Set the path to the queries JSON file.\n\tflag.StringVar(\u0026queriesFile, \"queriesFile\", \"queries.json\", \"Path to the queries JSON file\")\n\tflag.StringVar(\u0026anwsersFile, \"answersFile\", \"answers.json\", \"Path to the answers JSON file\")\n\tflag.StringVar(\u0026automaticApprovalFile, \"automaticApproval\", \"automatic_approval.json\", \"Path to the automatic_approval JSON file\")\n\tflag.StringVar(\u0026vectorPath, \"vector_db\", \"/home/ubuntu/workspace/mrcp/mcp-go/examples/survey_server/vector_db\", \"Path to the queries JSON file\")\n\tflag.StringVar(\u0026sourcePath, \"rag_sources\", \"/home/ubuntu/workspace/mrcp/mcp-go/examples/survey_server/rag_sources.jsonl\", \"Path to the queries JSON file\")\n\tflag.Parse()\n\n\tlog.Printf(\"Using queries file: %s\", queriesFile)\n\n\tctx := context.Background()\n\tchromemCollection = setupChromemCollection(vectorPath)\n\tfeedChromem(ctx, sourcePath, false)\n\n\tlog.Println(\"Finished!\")\n\n\tmcpServer := NewMCPQueryServer()\n\n\tif transport == \"sse\" {\n\t\tsseServer := server.NewSSEServer(mcpServer, server.WithBaseURL(\"http://localhost:8080\"))\n\t\tlog.Printf(\"SSE server listening on :8080\")\n\t\tif err := sseServer.Start(\":8080\"); err != nil {\n\t\t\tlog.Fatalf(\"Server error: %v\", err)\n\t\t}\n\t} else {\n\t\tif err := server.ServeStdio(mcpServer); err != nil {\n\t\t\tlog.Fatalf(\"Server error: %v\", err)\n\t\t}\n\t}\n}\n"}
{"file":"main.go","text":"package main\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"github.com/mark3labs/mcp-go/mcp\"\n\t\"github.com/mark3labs/mcp-go/server\"\n\t\"github.com/philippgille/chromem-go\"\n\topenai \"github.com/sashabaranov/go-openai\"\n\t\"io\"\n\t\"io/fs\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Global file path for queries.\nvar queriesFile string\nvar anwsersFile string\nvar automaticApprovalFile string\nvar chromemCollection *chromem.Collection\nvar vectorPath string\nvar sourcePath string\n\n// -----------------------------------------------------------------------------\n// Data Structures for Queries\n// -----------------------------------------------------------------------------\n\ntype Query struct {\n\tID               string   `json:\"id\"`\n\tFrom             string   `json:\"from\"`\n\tQuestion         string   `json:\"question\"`\n\tAnswer           string   `json:\"answer\"`\n\tDocumentsRelated []string `json:\"documents_related\"`\n\tStatus           string   `json:\"status\"`\n  Reason           string   `json:\"reason\"`\n}\n\ntype QueriesData struct {\n\tQueries map[string]Query `json:\"queries\"`\n}\n\ntype Document struct {\n\tContent  string `json:\"content\"`\n\tFileName string `json:\"file\"`\n}\n\n// -----------------------------------------------------------------------------\n// Helper Functions: File I/O for Queries\n// -----------------------------------------------------------------------------\n\nfunc loadQueries() (QueriesData, error) {\n\tvar data QueriesData\n\t// If file doesn't exist, initialize an empty map.\n\tif _, err := os.Stat(queriesFile); os.IsNotExist(err) {\n\t\tdata.Queries = make(map[string]Query)\n\t\treturn data, nil\n\t}\n\traw, err := os.ReadFile(queriesFile)\n\tif err != nil {\n\t\treturn data, fmt.Errorf(\"failed to read queries file: %w\", err)\n\t}\n\tif err := json.Unmarshal(raw, \u0026data); err != nil {\n\t\treturn data, fmt.Errorf(\"failed to unmarshal queries file: %w\", err)\n\t}\n\treturn data, nil\n}\n\nfunc saveQueries(data QueriesData) error {\n\t// Ensure directory exists.\n\tdir := filepath.Dir(queriesFile)\n\tif err := os.MkdirAll(dir, fs.ModePerm); err != nil {\n\t\treturn fmt.Errorf(\"failed to create directory %s: %w\", dir, err)\n\t}\n\traw, err := json.MarshalIndent(data, \"\", \"  \")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal queries data: %w\", err)\n\t}\n\tif err := os.WriteFile(queriesFile, raw, 0644); err != nil {\n\t\treturn fmt.Errorf(\"failed to write queries file: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc generateQueryID() (string, error) {\n\tb := make([]byte, 8)\n\tif _, err := rand.Read(b); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn \"qry-\" + hex.EncodeToString(b), nil\n}\n\n// -----------------------------------------------------------------------------\n// Mocked RAG and Answer Generation Functions\n// -----------------------------------------------------------------------------\n\n// mockRetrieveDocuments simulates retrieval of documents related to the query.\nfunc mockRetrieveDocuments(question string) []string {\n\t// In a real system, this would involve searching an index or using embeddings.\n\t// Here we simply return a dummy list.\n\treturn []string{\"doc1\", \"doc2\"}\n}\n\nfunc retrieveDocuments(ctx context.Context, question string, numResults int) ([]Document, error) {\n\t// For the Ollama embedding model, a prefix is required to differentiate between a query and a document.\n\t// The documents were stored with \"search_document: \" as a prefix, so we use \"search_query: \" here.\n\tquery := \"search_query: \" + question\n\n\t// Query the collection for the top 'numResults' similar documents.\n\tdocRes, err := chromemCollection.Query(ctx, query, numResults, nil, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar results []Document = []Document{}\n\tfor _, res := range docRes {\n\t\t// Cut off the prefix we added before adding the document (see comment above).\n\t\t// This is specific to the \"nomic-embed-text\" model.\n\t\t// content := strings.TrimPrefix(res.Content, \"search_document: \")\n\t\tcontent := Document{FileName: res.Metadata[\"file\"], Content: res.Content}\n\t\tresults = append(results, content)\n\t}\n\n\tif len(results) \u003e numResults {\n\t\tresults = results[:numResults]\n\t}\n\treturn results, nil\n}\n\nfunc generateAnswer(ctx context.Context, client *openai.Client, question string, docs []Document) (string, error) {\n\t// Construct a prompt that includes the question and context from the documents.\n\tprompt := fmt.Sprintf(\"You are an AI assistant that answers questions based on the context provided in the documents.\\n\\nQuestion: %s\\n\\nDocuments:\\n\", question)\n\tfor i, doc := range docs {\n\t\tprompt += fmt.Sprintf(\"Document %d - %s:\\n%s\\n\\n\", i+1, doc.FileName, doc.Content)\n\t}\n\tprompt += \"Answer:\"\n\n\t// Use ChatCompletion for answer generation.\n\tchatReq := openai.ChatCompletionRequest{\n\t\tModel: openai.GPT3Dot5Turbo,\n\t\tMessages: []openai.ChatCompletionMessage{\n\t\t\t{Role: \"system\", Content: \"You are a helpful AI assistant. Your task is to answer questions based on the context provided in the documents. Answer in first person.\"},\n\t\t\t{Role: \"user\", Content: prompt},\n\t\t},\n\t}\n\tchatResp, err := client.CreateChatCompletion(ctx, chatReq)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to generate answer: %w\", err)\n\t}\n\tif len(chatResp.Choices) == 0 {\n\t\treturn \"\", fmt.Errorf(\"no answer returned\")\n\t}\n\tanswer := chatResp.Choices[0].Message.Content\n\treturn answer, nil\n}\n\nfunc checkAutomaticApprovalConditions(ctx context.Context, answer string, query Query, client *openai.Client) (string, bool) {\n\tvar conditions []string\n\n\tif _, err := os.Stat(automaticApprovalFile); os.IsNotExist(err) {\n\t\treturn \"No automatic approval file\", false\n\t}\n\n\traw, err := os.ReadFile(automaticApprovalFile)\n\tif err != nil {\n\t\treturn \"Error reading automatic approval file: \", false\n\t}\n\tif err := json.Unmarshal(raw, \u0026conditions); err != nil {\n\t\treturn \"Error unmarshaling automatic approval file: \", false\n\t}\n\n\t// Format the list as a pretty JSON string.\n\tformatted, err := json.MarshalIndent(conditions, \"\", \"  \")\n\tif err != nil {\n\t\treturn \"Error formatting conditions as JSON: \", false\n\t}\n  prompt := fmt.Sprintf(\"Query:'%s'\\n\\n'Queried From:'%s'\\n\\n My Answer: '%s'\\n\\nConditions: %s\\n\",query.Question, query.From, answer, string(formatted))\n\t// Use ChatCompletion for answer generation.\n\tchatReq := openai.ChatCompletionRequest{\n\t\tModel: openai.GPT4oMini,\n\t\tMessages: []openai.ChatCompletionMessage{\n\t\t\t{Role: \"system\", Content: \"You are an AI assistant responsible for verifying that if given fields=(query, queried from, and answer). Check if they satisfies all specified conditions with no tolerance for minor deviations. Evaluate the answer against each condition, and then return only a JSON object with a two keys, 'result' and 'reason', set to true if every condition is met, or false if any condition fails. The 'reason' key should contain a brief explanation of why the result is true or false. Do not include any additional text or formatting.\"},\n\t\t\t{Role: \"user\", Content: prompt},\n\t\t},\n\t\tResponseFormat: \u0026openai.ChatCompletionResponseFormat{Type: \"json_object\"},\n\t}\n\tchatResp, err := client.CreateChatCompletion(ctx, chatReq)\n\tif err != nil {\n\t\treturn \"Error generating answer: \", false\n\t}\n\tif len(chatResp.Choices) == 0 {\n\t\treturn \"No answer returned\", false\n\t}\n\tresponse := chatResp.Choices[0].Message.Content\n\t// var result map[string]bool\n  var result struct {\n\t\tResult bool `json:\"result\"`\n\t\tReason string `json:\"reason\"`\n\t}\n\tif err := json.Unmarshal([]byte(response), \u0026result); err != nil {\n\t\treturn \"Error unmarshaling response: \", false\n\t}\n\treturn result.Reason, result.Result \n}\n\n// Tool: Add Automatic Approval Condition\n//\n// This tool extracts a condition from a sentence and appends it to the automatic_approval.json file.\n// The file is expected to store an array of condition strings.\n// Input parameter: \"sentence\" (the sentence containing the condition).\nfunc handleAddApprovalConditionTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\targs := request.Params.Arguments\n\tsentence, ok := args[\"sentence\"].(string)\n\tif !ok || strings.TrimSpace(sentence) == \"\" {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"'sentence' parameter is required\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Extract the condition (for now, simply trim the sentence).\n\tcondition := strings.TrimSpace(sentence)\n\n\t// Load existing conditions (if file exists).\n\tvar conditions []string\n\tif _, err := os.Stat(automaticApprovalFile); os.IsNotExist(err) {\n\t\tconditions = []string{}\n\t} else {\n\t\traw, err := os.ReadFile(automaticApprovalFile)\n\t\tif err != nil {\n\t\t\treturn \u0026mcp.CallToolResult{\n\t\t\t\tContent: []mcp.Content{\n\t\t\t\t\tmcp.TextContent{\n\t\t\t\t\t\tType: \"text\",\n\t\t\t\t\t\tText: fmt.Sprintf(\"Error reading automatic approval file: %v\", err),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t}\n\t\tif err := json.Unmarshal(raw, \u0026conditions); err != nil {\n\t\t\treturn \u0026mcp.CallToolResult{\n\t\t\t\tContent: []mcp.Content{\n\t\t\t\t\tmcp.TextContent{\n\t\t\t\t\t\tType: \"text\",\n\t\t\t\t\t\tText: fmt.Sprintf(\"Error unmarshalling automatic approval file: %v\", err),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t}\n\t}\n\n\t// Append the new condition.\n\tconditions = append(conditions, condition)\n\n\t// Marshal the updated conditions.\n\tupdatedRaw, err := json.MarshalIndent(conditions, \"\", \"  \")\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error marshalling updated conditions: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Ensure the directory exists.\n\tapprovalDir := filepath.Dir(automaticApprovalFile)\n\tif err := os.MkdirAll(approvalDir, fs.ModePerm); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error creating directory for automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Write the updated file.\n\tif err := os.WriteFile(automaticApprovalFile, updatedRaw, 0644); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error writing automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"Condition added successfully: %s\", condition),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// Tool: List Automatic Approval Conditions\n//\n// This tool retrieves and returns the list of conditions from the automatic_approval.json file.\nfunc handleListApprovalConditionsTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\tvar conditions []string\n\n\tif _, err := os.Stat(automaticApprovalFile); os.IsNotExist(err) {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"No automatic approval conditions found.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\traw, err := os.ReadFile(automaticApprovalFile)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error reading automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tif err := json.Unmarshal(raw, \u0026conditions); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error unmarshalling automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Format the list as a pretty JSON string.\n\tformatted, err := json.MarshalIndent(conditions, \"\", \"  \")\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error formatting conditions: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: string(formatted),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// Tool: Remove Automatic Approval Condition\n//\n// This tool removes a specific condition from the automatic_approval.json file.\n// Input parameter: \"condition\" (the exact text of the condition to remove).\nfunc handleRemoveApprovalConditionTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\targs := request.Params.Arguments\n\tconditionToRemove, ok := args[\"condition\"].(string)\n\tif !ok || strings.TrimSpace(conditionToRemove) == \"\" {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"'condition' parameter is required\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tconditionToRemove = strings.TrimSpace(conditionToRemove)\n\tvar conditions []string\n\n\tif _, err := os.Stat(automaticApprovalFile); os.IsNotExist(err) {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"No automatic approval conditions found.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\traw, err := os.ReadFile(automaticApprovalFile)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error reading automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tif err := json.Unmarshal(raw, \u0026conditions); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error unmarshalling automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Remove the specified condition.\n\tfound := false\n\tnewConditions := []string{}\n\tfor _, cond := range conditions {\n\t\tif cond == conditionToRemove {\n\t\t\tfound = true\n\t\t\tcontinue\n\t\t}\n\t\tnewConditions = append(newConditions, cond)\n\t}\n\n\tif !found {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Condition '%s' not found.\", conditionToRemove),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Marshal and write the updated list back to the file.\n\tupdatedRaw, err := json.MarshalIndent(newConditions, \"\", \"  \")\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error marshalling updated conditions: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tapprovalDir := filepath.Dir(automaticApprovalFile)\n\tif err := os.MkdirAll(approvalDir, fs.ModePerm); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error creating directory for automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tif err := os.WriteFile(automaticApprovalFile, updatedRaw, 0644); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error writing automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"Condition '%s' removed successfully.\", conditionToRemove),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\nfunc handleSaveAnswerTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\t// Retrieve and validate input parameters.\n\targs := request.Params.Arguments\n\n\tqueryID, ok := args[\"query\"].(string)\n\tif !ok || strings.TrimSpace(queryID) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'query' parameter is required\")\n\t}\n\tfrom, ok := args[\"from\"].(string)\n\tif !ok || strings.TrimSpace(from) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'from' parameter is required\")\n\t}\n\tanswer, ok := args[\"answer\"].(string)\n\tif !ok || strings.TrimSpace(answer) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'answer' parameter is required\")\n\t}\n\n\t// Load existing answers from the file.\n\tvar answersData map[string]map[string]string\n\tif _, err := os.Stat(anwsersFile); os.IsNotExist(err) {\n\t\t// File doesn't exist; initialize a new map.\n\t\tanswersData = make(map[string]map[string]string)\n\t} else {\n\t\traw, err := os.ReadFile(anwsersFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to read answers file: %w\", err)\n\t\t}\n\t\tif err := json.Unmarshal(raw, \u0026answersData); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal answers file: %w\", err)\n\t\t}\n\t}\n\n\t// Check if the query_id exists. If not, create a new entry.\n\tif answersData[queryID] == nil {\n\t\tanswersData[queryID] = make(map[string]string)\n\t}\n\n\t// Append (or update) the new answer using both the 'from' and 'to' keys.\n\tanswersData[queryID][from] = answer\n\n\t// Marshal the updated answersData back to JSON.\n\tupdatedRaw, err := json.MarshalIndent(answersData, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal answers data: %w\", err)\n\t}\n\n\t// Ensure the directory exists (using the same pattern as in saveQueries).\n\tanswersDir := filepath.Dir(anwsersFile)\n\tif err := os.MkdirAll(answersDir, fs.ModePerm); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create directory %s: %w\", answersDir, err)\n\t}\n\n\t// Write the updated JSON back to the file.\n\tif err := os.WriteFile(anwsersFile, updatedRaw, 0644); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write answers file: %w\", err)\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"Answer updated successfully for query: %s\", queryID),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// Tool: Manage Answer for Query\n//\n// This tool manages answers for a given query. It expects the following parameters:\n//   - query_id: The ID of the query.\n//   - from: The sender identifier.\n//   - to: The recipient identifier.\n//   - answer: The answer text.\n//\n// The answers.json file is structured as follows:\n//\n//\t{\n//\t  \"\u003cquery_id\u003e\": {\n//\t    \"\u003cfrom\u003e\": \"\u003canswer_value\u003e\",\n//\t    \"\u003cto\u003e\": \"\u003canswer_value\u003e\"\n//\t  }\n//\t}\nfunc handleSendAnswerTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\t// Retrieve and validate input parameters.\n\targs := request.Params.Arguments\n\n\tqueryID, ok := args[\"query\"].(string)\n\tif !ok || strings.TrimSpace(queryID) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'query' parameter is required\")\n\t}\n\tfrom, ok := args[\"from\"].(string)\n\tif !ok || strings.TrimSpace(from) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'from' parameter is required\")\n\t}\n\t// to, ok := args[\"to\"].(string)\n\t// if !ok || strings.TrimSpace(to) == \"\" {\n\t// \treturn nil, fmt.Errorf(\"'to' parameter is required\")\n\t// }\n\tanswer, ok := args[\"answer\"].(string)\n\tif !ok || strings.TrimSpace(answer) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'answer' parameter is required\")\n\t}\n\n\t// Load existing answers from the file.\n\tvar answersData map[string]map[string]string\n\tif _, err := os.Stat(anwsersFile); os.IsNotExist(err) {\n\t\t// File doesn't exist; initialize a new map.\n\t\tanswersData = make(map[string]map[string]string)\n\t} else {\n\t\traw, err := os.ReadFile(anwsersFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to read answers file: %w\", err)\n\t\t}\n\t\tif err := json.Unmarshal(raw, \u0026answersData); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal answers file: %w\", err)\n\t\t}\n\t}\n\n\t// Check if the query_id exists. If not, create a new entry.\n\tif answersData[queryID] == nil {\n\t\tanswersData[queryID] = make(map[string]string)\n\t}\n\n\t// Append (or update) the new answer using both the 'from' and 'to' keys.\n\tanswersData[queryID][from] = answer\n\n\t// Marshal the updated answersData back to JSON.\n\tupdatedRaw, err := json.MarshalIndent(answersData, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal answers data: %w\", err)\n\t}\n\n\t// Ensure the directory exists (using the same pattern as in saveQueries).\n\tanswersDir := filepath.Dir(anwsersFile)\n\tif err := os.MkdirAll(answersDir, fs.ModePerm); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create directory %s: %w\", answersDir, err)\n\t}\n\n\t// Write the updated JSON back to the file.\n\tif err := os.WriteFile(anwsersFile, updatedRaw, 0644); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write answers file: %w\", err)\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"Answer updated successfully for query: %s\", queryID),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// Tool: Get Answers for Query\n//\n// This tool retrieves all answers associated with a given answer_id.\n// The answers.json file is expected to have the following structure:\n//\n//\t{\n//\t  \"\u003cquery_id\u003e\": {\n//\t    \"\u003cfrom\u003e\": \"\u003canswer_value\u003e\",\n//\t    \"\u003cto\u003e\": \"\u003canswer_value\u003e\"\n//\t  }\n//\t}\n//\n// Given an answer_id, this tool will load the file, check if the entry exists,\n// and return the associated answers. In case of any error, the error message\n// will be returned in the Text field of the CallToolResult.\nfunc handleGetAnswersTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\t// Retrieve and validate input parameter.\n\targs := request.Params.Arguments\n\tqueryId, ok := args[\"query\"].(string)\n\tif !ok || strings.TrimSpace(queryId) == \"\" {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"'query_id' parameter is required\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Load existing answers from the file.\n\tvar answersData map[string]map[string]string\n\tif _, err := os.Stat(anwsersFile); os.IsNotExist(err) {\n\t\t// File doesn't exist; therefore, no answers can be found.\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"No answers found for id: %s\", queryId),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t} else {\n\t\traw, err := os.ReadFile(anwsersFile)\n\t\tif err != nil {\n\t\t\treturn \u0026mcp.CallToolResult{\n\t\t\t\tContent: []mcp.Content{\n\t\t\t\t\tmcp.TextContent{\n\t\t\t\t\t\tType: \"text\",\n\t\t\t\t\t\tText: fmt.Sprintf(\"Error reading answers file: %v\", err),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t}\n\t\tif err := json.Unmarshal(raw, \u0026answersData); err != nil {\n\t\t\treturn \u0026mcp.CallToolResult{\n\t\t\t\tContent: []mcp.Content{\n\t\t\t\t\tmcp.TextContent{\n\t\t\t\t\t\tType: \"text\",\n\t\t\t\t\t\tText: fmt.Sprintf(\"Error unmarshalling answers file: %v\", err),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t}\n\t}\n\n\t// Check if the answer_id exists in the loaded data.\n\tif answers, exists := answersData[queryId]; exists {\n\t\t// Format the answers as a pretty JSON string.\n\t\tformatted, err := json.MarshalIndent(answers, \"\", \"  \")\n\t\tif err != nil {\n\t\t\treturn \u0026mcp.CallToolResult{\n\t\t\t\tContent: []mcp.Content{\n\t\t\t\t\tmcp.TextContent{\n\t\t\t\t\t\tType: \"text\",\n\t\t\t\t\t\tText: fmt.Sprintf(\"Error formatting answer data: %v\", err),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t}\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: string(formatted),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// If answer_id is not found, return a message indicating so.\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"No answers found for id: %s\", queryId),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// -----------------------------------------------------------------------------\n// MCP Tool Handlers for Query Management\n// -----------------------------------------------------------------------------\n\n// Tool: Ask New Query\n//\n// Creates a new query. It requires a \"question\" argument and uses the userOrigin as the \"from\" field.\n// It mocks document retrieval and answer generation, saves the new query with status \"accepted\",\n// and returns the generated answer.\n//\n// Example usage:\n//\n//\t{\n//\t  \"tool\": \"cqAskNewQuery\",\n//\t  \"arguments\": {\n//\t      \"question\": \"What is the capital of France?\"\n//\t  }\n//\t}\nfunc handleAskNewQueryTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\topenaiClient := openai.NewClient(\"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\")\n\ts := server.ServerFromContext(ctx)\n\n\targs := request.Params.Arguments\n\tquestion, ok := args[\"question\"].(string)\n\tif !ok || strings.TrimSpace(question) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'question' parameter is required\")\n\t}\n\tuserOrigin := request.Params.Meta.Origin\n\n\t// Mock RAG: Retrieve relevant documents.\n\t// docs := mockRetrieveDocuments(question)\n\tdocs, err := retrieveDocuments(ctx, question, 3)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error retrieving documents: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\tanswer, err := generateAnswer(ctx, openaiClient, question, docs)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error generating answer: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Generate new query ID.\n\tnewID, err := generateQueryID()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to generate query ID: %w\", err)\n\t}\n\n\t// Load existing queries.\n\tqueriesData, err := loadQueries()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif queriesData.Queries == nil {\n\t\tqueriesData.Queries = make(map[string]Query)\n\t}\n\n\tvar docFilenames []string = []string{}\n\tfor _, doc := range docs {\n\t\tdocFilenames = append(docFilenames, doc.FileName)\n\t}\n\n\t// Create new query.\n\tnewQuery := Query{\n\t\tID:               newID,\n\t\tFrom:             userOrigin,\n\t\tQuestion:         question,\n\t\tAnswer:           answer,\n\t\tDocumentsRelated: docFilenames,\n\t\tStatus:           \"pending\",\n\t}\n\treason, automaticApproval := checkAutomaticApprovalConditions(ctx, answer, newQuery, openaiClient)\n\tif automaticApproval {\n\t\tnewQuery.Status = \"accepted\"\n\t}\n  newQuery.Reason = reason\n\tqueriesData.Queries[newID] = newQuery\n\n\t// Save queries.\n\tif err := saveQueries(queriesData); err != nil {\n\t\treturn nil, err\n\t}\n\tif automaticApproval {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"%s's Answer: %s\", s.Id, answer),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t} else {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Query created successfully with ID: %s\\n\", newID),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n}\n\n// Tool: List Queries\n//\nfunc handleListQueriesTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\t// Load all queries from the file.\n\tqueriesData, err := loadQueries()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Retrieve optional filter parameters.\n\targs := request.Params.Arguments\n\tvar statusFilter string\n\tvar fromFilter string\n\n\t// Use \"status\" filter if provided.\n\tif statusVal, ok := args[\"status\"].(string); ok \u0026\u0026 strings.TrimSpace(statusVal) != \"\" {\n\t\tstatusFilter = strings.ToLower(strings.TrimSpace(statusVal))\n\t}\n\t// Use \"from\" filter if provided.\n\tif fromVal, ok := args[\"from\"].(string); ok \u0026\u0026 strings.TrimSpace(fromVal) != \"\" {\n\t\tfromFilter = strings.TrimSpace(fromVal)\n\t}\n\n\t// If no filters are provided, return the complete list.\n\tif statusFilter == \"\" \u0026\u0026 fromFilter == \"\" {\n\t\toutput, err := json.MarshalIndent(queriesData.Queries, \"\", \"  \")\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to marshal queries: %w\", err)\n\t\t}\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: string(output),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Filter queries based on provided optional parameters.\n\tfiltered := make(map[string]Query)\n\tfor id, qry := range queriesData.Queries {\n\t\t// Apply status filter if set.\n\t\tif statusFilter != \"\" {\n\t\t\tif strings.ToLower(qry.Status) != statusFilter {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\t// Apply from filter if set.\n\t\tif fromFilter != \"\" {\n\t\t\tif qry.From != fromFilter {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tfiltered[id] = qry\n\t}\n\n\t// Marshal the filtered queries into a pretty JSON string.\n\toutput, err := json.MarshalIndent(filtered, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal filtered queries: %w\", err)\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: string(output),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n\nfunc handleAcceptQueryTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\targs := request.Params.Arguments\n\ts := server.ServerFromContext(ctx)\n\n\tid, ok := args[\"id\"].(string)\n\tif !ok || strings.TrimSpace(id) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'id' parameter is required\")\n\t}\n\n\tqueriesData, err := loadQueries()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tqry, exists := queriesData.Queries[id]\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"query with ID '%s' not found\", id)\n\t}\n\n\t// Update status to \"accepted\" if not already.\n\tqry.Status = \"accepted\"\n\tqueriesData.Queries[id] = qry\n\n\tif err := saveQueries(queriesData); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"Question '%s' has been accepted.\\n Calling cqSendAnswer tool. Sending answer to @%s from %s answer: %s\", qry.Question, qry.From, s.Id, qry.Answer),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// -----------------------------------------------------------------------------\n// MCP Server: Registering Tools for Query Management\n// -----------------------------------------------------------------------------\n\nfunc NewMCPQueryServer() *server.MCPServer {\n\tmcpServer := server.NewMCPServer(\n\t\t\"example-servers/queries\",\n\t\t\"1.0.0\",\n\t\tserver.WithResourceCapabilities(true, true),\n\t\tserver.WithPromptCapabilities(true),\n\t\tserver.WithLogging(),\n\t)\n\n\t// Tool: Ask New Query\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqAskNewQuery\",\n\t\t\tmcp.WithDescription(\"Creates a new query using a question. It retrieves related documents, generates an answer, and saves the query with status 'accepted'.\"),\n\t\t\tmcp.WithString(\"question\", mcp.Description(\"The question for the query\"), mcp.Required()),\n\t\t\tmcp.WithPeer(),\n\t\t),\n\t\thandleAskNewQueryTool,\n\t)\n\n\t// Tool: Manage Answer\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqSendAnswer\",\n\t\t\tmcp.WithDescription(\"Sends an answer to a query.\"),\n\t\t\tmcp.WithString(\"query\", mcp.Description(\"Question made in the query\"), mcp.Required()),\n\t\t\tmcp.WithString(\"from\", mcp.Description(\"Sender of the answer\"), mcp.Required()),\n\t\t\tmcp.WithString(\"answer\", mcp.Description(\"The answer text\"), mcp.Required()),\n\t\t\tmcp.WithPeer(),\n\t\t),\n\t\thandleSendAnswerTool,\n\t)\n\n\t// mcpServer.AddTool(\n\t// \tmcp.NewTool(\"cqSavesAnswer\",\n\t// \t\tmcp.WithDescription(\"Saves an answer to a query.\"),\n\t// \t\tmcp.WithString(\"query\", mcp.Description(\"Question made in the query\"), mcp.Required()),\n\t// \t\tmcp.WithString(\"from\", mcp.Description(\"Sender of the answer\"), mcp.Required()),\n\t// \t\tmcp.WithString(\"answer\", mcp.Description(\"The answer text\"), mcp.Required()),\n\t// \t),\n\t// \thandleSaveAnswerTool,\n\t// )\n\n  // Tool: List Queries\n  mcpServer.AddTool(\n    mcp.NewTool(\"cqListQueries\",\n      mcp.WithDescription(\"Lists all queries.\"),\n      mcp.WithString(\"status\", mcp.Description(\"Filter by status (optional)\")),\n      mcp.WithString(\"from\", mcp.Description(\"Filter by sender (optional)\")),\n    ),\n    handleListQueriesTool,\n  )\n\n\t// Tool: Get Answers\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqGetAnswer\",\n\t\t\tmcp.WithDescription(\"Retrieves answer for a given query question.\"),\n\t\t\tmcp.WithString(\"query\", mcp.Description(\"Question of the query to retrieve answers for\"), mcp.Required()),\n\t\t),\n\t\thandleGetAnswersTool,\n\t)\n\n\t// Tool: Accept Query\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqAcceptQuery\",\n\t\t\tmcp.WithDescription(\"Accepts a pending query by updating its status to 'accepted'.\"),\n\t\t\tmcp.WithString(\"id\", mcp.Description(\"ID of the query to accept\"), mcp.Required()),\n\t\t),\n\t\thandleAcceptQueryTool,\n\t)\n\n\t// Tool: Add Automatic Approval Condition\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqAddAutoApprovalCondition\",\n\t\t\tmcp.WithDescription(\"Extracts a condition from a sentence and appends it to automatic_approval.json.\"),\n\t\t\tmcp.WithString(\"sentence\", mcp.Description(\"Sentence containing the condition\"), mcp.Required()),\n\t\t),\n\t\thandleAddApprovalConditionTool,\n\t)\n\n\t// Tool: List Automatic Approval Conditions\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqListAutoApprovalConditions\",\n\t\t\tmcp.WithDescription(\"Lists all automatic approval conditions from automatic_approval.json.\"),\n\t\t\tmcp.WithBoolean(\"flag\", mcp.DefaultBool(false), mcp.Description(\"Ignore this parameter\")),\n\t\t),\n\t\thandleListApprovalConditionsTool,\n\t)\n\n\t// Tool: Remove Automatic Approval Condition\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqRemoveAutoApprovalCondition\",\n\t\t\tmcp.WithDescription(\"Removes a specific condition from automatic_approval.json.\"),\n\t\t\tmcp.WithString(\"condition\", mcp.Description(\"The condition text to remove\"), mcp.Required()),\n\t\t),\n\t\thandleRemoveApprovalConditionTool,\n\t)\n\n\t// -------------------------------------------------------------------------\n\t// New Tool Registration: Add RAG Resource\n\t// -------------------------------------------------------------------------\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqUpdateRagKnowledgeBase\",\n\t\t\tmcp.WithDescription(\"Adds a new RAG resource by loading a file's content, appending it to the rag_sources file, and refreshing the vector database.\"),\n\t\t\tmcp.WithString(\"file_path\", mcp.Description(\"Path to the file to add as a RAG resource\"), mcp.Required()),\n\t\t),\n\t\thandleAddRagResourceTool,\n\t)\n\n\treturn mcpServer\n}\n\nfunc setupChromemCollection(vectorPath string) *chromem.Collection {\n\t// Setup chromem-go\n\tdb, err := chromem.NewPersistentDB(vectorPath, false)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tembeddingModel := \"nomic-embed-text\"\n\n\t// Create collection if it wasn't loaded from persistent storage yet.\n\t// You can pass nil as embedding function to use the default (OpenAI text-embedding-3-small),\n\t// which is very good and cheap. It would require the OPENAI_API_KEY environment\n\t// variable to be set.\n\t// For this example we choose to use a locally running embedding model though.\n\t// It requires Ollama to serve its API at \"http://localhost:11434/api\".\n\tcollection, err := db.GetOrCreateCollection(\"Wikipedia\", nil, chromem.NewEmbeddingFuncOllama(embeddingModel, \"\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn collection\n}\n\nfunc feedChromem(ctx context.Context, sourcePath string, update bool) {\n\t// Feed chromem with documents\n\tvar docs []chromem.Document\n\tif chromemCollection.Count() == 0  || update {\n\t\t// Here we use a DBpedia sample, where each line contains the lead section/introduction\n\t\t// to some Wikipedia article and its category.\n\t\tf, err := os.Open(sourcePath)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdefer f.Close()\n\t\td := json.NewDecoder(f)\n\t\tfor i := 1; ; i++ {\n\t\t\tvar article struct {\n\t\t\t\tText     string `json:\"text\"`\n\t\t\t\tFileName string `json:\"file\"`\n\t\t\t}\n\t\t\terr := d.Decode(\u0026article)\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t} else if err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\t// The embeddings model we use in this example (\"nomic-embed-text\")\n\t\t\t// fare better with a prefix to differentiate between document and query.\n\t\t\t// We'll have to cut it off later when we retrieve the documents.\n\t\t\t// An alternative is to create the embedding with `chromem.NewDocument()`,\n\t\t\t// and then change back the content before adding it do the collection\n\t\t\t// with `collection.AddDocument()`.\n\t\t\tcontent := \"search_document: \" + article.Text\n\n\t\t\tdocs = append(docs, chromem.Document{\n\t\t\t\tID:       strconv.Itoa(i),\n\t\t\t\tMetadata: map[string]string{\"file\": article.FileName},\n\t\t\t\tContent:  content,\n\t\t\t})\n\t\t}\n\t\tlog.Println(\"Adding documents to chromem-go, including creating their embeddings via Ollama API...\")\n\t\terr = chromemCollection.AddDocuments(ctx, docs, runtime.NumCPU())\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t} else {\n\t\tlog.Println(\"Not reading JSON lines because collection was loaded from persistent storage.\")\n\t}\n}\n\n// -----------------------------------------------------------------------------\n// Tool: Add RAG Resource\n//\n// This tool accepts a file path as input, reads the file content, and appends a new\n// RAG resource to the rag_sources file. The expected structure for each RAG resource\n// is: {\"file\": \u003cfilename\u003e, \"text\": \u003ctext\u003e}\n// After updating the file, it refreshes the vector database by invoking feedChromem.\n//\n// Example usage:\n//\n//\t{\n//\t  \"tool\": \"cqAddRagResource\",\n//\t  \"arguments\": {\n//\t    \"file_path\": \"/path/to/resource.txt\"\n//\t  }\n//\t}\nfunc handleAddRagResourceTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\t// Retrieve the file_path parameter.\n\targs := request.Params.Arguments\n\tfilePath, ok := args[\"file_path\"].(string)\n\tif !ok || strings.TrimSpace(filePath) == \"\" {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"'file_path' parameter is required\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Read the content from the specified file.\n\tdata, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error reading file at '%s': %v\", filePath, err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Extract the base filename.\n\tbaseFile := filepath.Base(filePath)\n\n\t// Create a new RAG resource object.\n\tresource := map[string]string{\n\t\t\"file\": baseFile,\n\t\t\"text\": string(data),\n\t}\n\n\t// Marshal the resource to JSON.\n\tresourceJSON, err := json.Marshal(resource)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error marshalling resource: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Open the RAG sources file (sourcePath) in append mode.\n\tf, err := os.OpenFile(sourcePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error opening RAG sources file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tdefer f.Close()\n\n\t// Write the JSON object as a new line in the file.\n\tif _, err := f.Write(append(resourceJSON, '\\n')); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error writing to RAG sources file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Log the successful addition.\n\tlog.Printf(\"Added new RAG resource: %s\", baseFile)\n\n\t// Refresh the vector database by invoking feedChromem.\n\t// Note: feedChromem reads the rag_sources file and adds documents if the collection is empty.\n\tfeedChromem(ctx, sourcePath, true)\n\n\t// Return a success message.\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"RAG resource '%s' added successfully and vector database refreshed.\", baseFile),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// -----------------------------------------------------------------------------\n// Main Function\n// -----------------------------------------------------------------------------\nfunc main() {\n\tvar transport string\n\t// Set the path to the queries JSON file.\n\tflag.StringVar(\u0026queriesFile, \"queriesFile\", \"queries.json\", \"Path to the queries JSON file\")\n\tflag.StringVar(\u0026anwsersFile, \"answersFile\", \"answers.json\", \"Path to the answers JSON file\")\n\tflag.StringVar(\u0026automaticApprovalFile, \"automaticApproval\", \"automatic_approval.json\", \"Path to the automatic_approval JSON file\")\n\tflag.StringVar(\u0026vectorPath, \"vector_db\", \"/home/ubuntu/workspace/mrcp/mcp-go/examples/survey_server/vector_db\", \"Path to the queries JSON file\")\n\tflag.StringVar(\u0026sourcePath, \"rag_sources\", \"/home/ubuntu/workspace/mrcp/mcp-go/examples/survey_server/rag_sources.jsonl\", \"Path to the queries JSON file\")\n\tflag.Parse()\n\n\tlog.Printf(\"Using queries file: %s\", queriesFile)\n\n\tctx := context.Background()\n\tchromemCollection = setupChromemCollection(vectorPath)\n\tfeedChromem(ctx, sourcePath, false)\n\n\tlog.Println(\"Finished!\")\n\n\tmcpServer := NewMCPQueryServer()\n\n\tif transport == \"sse\" {\n\t\tsseServer := server.NewSSEServer(mcpServer, server.WithBaseURL(\"http://localhost:8080\"))\n\t\tlog.Printf(\"SSE server listening on :8080\")\n\t\tif err := sseServer.Start(\":8080\"); err != nil {\n\t\t\tlog.Fatalf(\"Server error: %v\", err)\n\t\t}\n\t} else {\n\t\tif err := server.ServeStdio(mcpServer); err != nil {\n\t\t\tlog.Fatalf(\"Server error: %v\", err)\n\t\t}\n\t}\n}\n"}
{"file":"README.md","text":"```\n ____         __ _   ____\n/ ___| _   _ / _| |_| __ )  _____  __\n\\___ \\| | | | |_| __|  _ \\ / _ \\ \\/ /\n ___) | |_| |  _| |_| |_) | (_) \u003e  \u003c\n|____/ \\__, |_|  \\__|____/ \\___/_/\\_\\\n       |___/\n```\n\n# Quickstart User Installation\n\n## SyftBox 1 liner\n\ncurl -LsSf https://syftbox.openmined.org/install.sh | sh -s -- run\n\n## Manual install\n\n### install uv\n\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n### create a virtualenv somewhere\n\nuv venv .venv\n\n### Install Syftbox\n\nuv pip install -U syftbox\n\n### run the client\n\nuv run syftbox client\n\n# Quickstart Client Developer Installation\n\n### Step 0: Open your terminal to the root of this Github repository\n\nBegin by opening your terminal and navigating to the root directory of this github repository (so when you run 'ls' it should show folders like \"syftbox\", \"server\", \"tests\", etc.). Then run the commands in steps 1-4:\n\n### Step 1: Install Homebrew\n\n```\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n### Step 2: Install uv (using homebrew — which is better for this than pip)\n\n```\nbrew install uv\n```\n\n### Step 3: Install a virtual environment using uv\n\n```\nuv venv\n```\n\n### Step 4: Install a relative version of uv.\n\n```\nuv pip install -e .\n```\n\n### Step 5: Run the client\n\n```\nuv run syftbox/client/client.py\n```\n\n# Alternative Options\n\n### Run Client\n\n```\nsyftbox client --config_path=./config.json --sync_folder=~/Desktop/SyftBox --email=your@email.org --port=8082  --server=https://syftbox.openmined.org\n```\n\n### Staging Server\n\nIf you have issues or want to use a bleeding edge server try --server=https://syftboxstage.openmined.org\n\n### Deploy\n\nThis builds the latest source to a wheel and deploys and restarts the server:\nhttps://syftbox.openmined.org\n\n```\n./scripts/deploy.sh\n```\n\n### Dev Mode\n\nRun the server and clients locally in editable mode with:\nServer:\n\n```\n./scripts/server.sh\n```\n\nClient1:\n\n```\n./scripts/madhava.sh\n```\n\nClient2:\n\n```\n./scripts/andrew.sh\n```\n"}
{"file":"main.go","text":"package main\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\t\"github.com/mark3labs/mcp-go/mcp\"\n\t\"github.com/mark3labs/mcp-go/server\"\n\t\"github.com/philippgille/chromem-go\"\n\topenai \"github.com/sashabaranov/go-openai\"\n\t\"io\"\n\t\"io/fs\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Global file path for queries.\nvar queriesFile string\nvar anwsersFile string\nvar automaticApprovalFile string\nvar chromemCollection *chromem.Collection\nvar vectorPath string\nvar sourcePath string\n\n// -----------------------------------------------------------------------------\n// Data Structures for Queries\n// -----------------------------------------------------------------------------\n\ntype Query struct {\n\tID               string   `json:\"id\"`\n\tFrom             string   `json:\"from\"`\n\tQuestion         string   `json:\"question\"`\n\tAnswer           string   `json:\"answer\"`\n\tDocumentsRelated []string `json:\"documents_related\"`\n\tStatus           string   `json:\"status\"`\n  Reason           string   `json:\"reason\"`\n}\n\ntype QueriesData struct {\n\tQueries map[string]Query `json:\"queries\"`\n}\n\ntype Document struct {\n\tContent  string `json:\"content\"`\n\tFileName string `json:\"file\"`\n}\n\n// -----------------------------------------------------------------------------\n// Helper Functions: File I/O for Queries\n// -----------------------------------------------------------------------------\n\nfunc loadQueries() (QueriesData, error) {\n\tvar data QueriesData\n\t// If file doesn't exist, initialize an empty map.\n\tif _, err := os.Stat(queriesFile); os.IsNotExist(err) {\n\t\tdata.Queries = make(map[string]Query)\n\t\treturn data, nil\n\t}\n\traw, err := os.ReadFile(queriesFile)\n\tif err != nil {\n\t\treturn data, fmt.Errorf(\"failed to read queries file: %w\", err)\n\t}\n\tif err := json.Unmarshal(raw, \u0026data); err != nil {\n\t\treturn data, fmt.Errorf(\"failed to unmarshal queries file: %w\", err)\n\t}\n\treturn data, nil\n}\n\nfunc saveQueries(data QueriesData) error {\n\t// Ensure directory exists.\n\tdir := filepath.Dir(queriesFile)\n\tif err := os.MkdirAll(dir, fs.ModePerm); err != nil {\n\t\treturn fmt.Errorf(\"failed to create directory %s: %w\", dir, err)\n\t}\n\traw, err := json.MarshalIndent(data, \"\", \"  \")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal queries data: %w\", err)\n\t}\n\tif err := os.WriteFile(queriesFile, raw, 0644); err != nil {\n\t\treturn fmt.Errorf(\"failed to write queries file: %w\", err)\n\t}\n\treturn nil\n}\n\nfunc generateQueryID() (string, error) {\n\tb := make([]byte, 8)\n\tif _, err := rand.Read(b); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn \"qry-\" + hex.EncodeToString(b), nil\n}\n\n// -----------------------------------------------------------------------------\n// Mocked RAG and Answer Generation Functions\n// -----------------------------------------------------------------------------\n\n// mockRetrieveDocuments simulates retrieval of documents related to the query.\nfunc mockRetrieveDocuments(question string) []string {\n\t// In a real system, this would involve searching an index or using embeddings.\n\t// Here we simply return a dummy list.\n\treturn []string{\"doc1\", \"doc2\"}\n}\n\nfunc retrieveDocuments(ctx context.Context, question string, numResults int) ([]Document, error) {\n\t// For the Ollama embedding model, a prefix is required to differentiate between a query and a document.\n\t// The documents were stored with \"search_document: \" as a prefix, so we use \"search_query: \" here.\n\tquery := \"search_query: \" + question\n\n\t// Query the collection for the top 'numResults' similar documents.\n\tdocRes, err := chromemCollection.Query(ctx, query, numResults, nil, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar results []Document = []Document{}\n\tfor _, res := range docRes {\n\t\t// Cut off the prefix we added before adding the document (see comment above).\n\t\t// This is specific to the \"nomic-embed-text\" model.\n\t\t// content := strings.TrimPrefix(res.Content, \"search_document: \")\n\t\tcontent := Document{FileName: res.Metadata[\"file\"], Content: res.Content}\n\t\tresults = append(results, content)\n\t}\n\n\tif len(results) \u003e numResults {\n\t\tresults = results[:numResults]\n\t}\n\treturn results, nil\n}\n\nfunc generateAnswer(ctx context.Context, client *openai.Client, question string, docs []Document) (string, error) {\n\t// Construct a prompt that includes the question and context from the documents.\n\tprompt := fmt.Sprintf(\"You are an AI assistant that answers questions based on the context provided in the documents.\\n\\nQuestion: %s\\n\\nDocuments:\\n\", question)\n\tfor i, doc := range docs {\n\t\tprompt += fmt.Sprintf(\"Document %d - %s:\\n%s\\n\\n\", i+1, doc.FileName, doc.Content)\n\t}\n\tprompt += \"Answer:\"\n\n\t// Use ChatCompletion for answer generation.\n\tchatReq := openai.ChatCompletionRequest{\n\t\tModel: openai.GPT3Dot5Turbo,\n\t\tMessages: []openai.ChatCompletionMessage{\n\t\t\t{Role: \"system\", Content: \"You are a helpful AI assistant. Your task is to answer questions based on the context provided in the documents. Answer in first person.\"},\n\t\t\t{Role: \"user\", Content: prompt},\n\t\t},\n\t}\n\tchatResp, err := client.CreateChatCompletion(ctx, chatReq)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to generate answer: %w\", err)\n\t}\n\tif len(chatResp.Choices) == 0 {\n\t\treturn \"\", fmt.Errorf(\"no answer returned\")\n\t}\n\tanswer := chatResp.Choices[0].Message.Content\n\treturn answer, nil\n}\n\nfunc checkAutomaticApprovalConditions(ctx context.Context, answer string, query Query, client *openai.Client) (string, bool) {\n\tvar conditions []string\n\n\tif _, err := os.Stat(automaticApprovalFile); os.IsNotExist(err) {\n\t\treturn \"No automatic approval file\", false\n\t}\n\n\traw, err := os.ReadFile(automaticApprovalFile)\n\tif err != nil {\n\t\treturn \"Error reading automatic approval file: \", false\n\t}\n\tif err := json.Unmarshal(raw, \u0026conditions); err != nil {\n\t\treturn \"Error unmarshaling automatic approval file: \", false\n\t}\n\n\t// Format the list as a pretty JSON string.\n\tformatted, err := json.MarshalIndent(conditions, \"\", \"  \")\n\tif err != nil {\n\t\treturn \"Error formatting conditions as JSON: \", false\n\t}\n  prompt := fmt.Sprintf(\"Query:'%s'\\n\\n'Queried From:'%s'\\n\\n My Answer: '%s'\\n\\nConditions: %s\\n\",query.Question, query.From, answer, string(formatted))\n\t// Use ChatCompletion for answer generation.\n\tchatReq := openai.ChatCompletionRequest{\n\t\tModel: openai.GPT4oMini,\n\t\tMessages: []openai.ChatCompletionMessage{\n\t\t\t{Role: \"system\", Content: \"You are an AI assistant responsible for verifying that if given fields=(query, queried from, and answer). Check if they satisfies all specified conditions with no tolerance for minor deviations. Evaluate the answer against each condition, and then return only a JSON object with a two keys, 'result' and 'reason', set to true if every condition is met, or false if any condition fails. The 'reason' key should contain a brief explanation of why the result is true or false. Do not include any additional text or formatting.\"},\n\t\t\t{Role: \"user\", Content: prompt},\n\t\t},\n\t\tResponseFormat: \u0026openai.ChatCompletionResponseFormat{Type: \"json_object\"},\n\t}\n\tchatResp, err := client.CreateChatCompletion(ctx, chatReq)\n\tif err != nil {\n\t\treturn \"Error generating answer: \", false\n\t}\n\tif len(chatResp.Choices) == 0 {\n\t\treturn \"No answer returned\", false\n\t}\n\tresponse := chatResp.Choices[0].Message.Content\n\t// var result map[string]bool\n  var result struct {\n\t\tResult bool `json:\"result\"`\n\t\tReason string `json:\"reason\"`\n\t}\n\tif err := json.Unmarshal([]byte(response), \u0026result); err != nil {\n\t\treturn \"Error unmarshaling response: \", false\n\t}\n\treturn result.Reason, result.Result \n}\n\n// Tool: Add Automatic Approval Condition\n//\n// This tool extracts a condition from a sentence and appends it to the automatic_approval.json file.\n// The file is expected to store an array of condition strings.\n// Input parameter: \"sentence\" (the sentence containing the condition).\nfunc handleAddApprovalConditionTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\targs := request.Params.Arguments\n\tsentence, ok := args[\"sentence\"].(string)\n\tif !ok || strings.TrimSpace(sentence) == \"\" {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"'sentence' parameter is required\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Extract the condition (for now, simply trim the sentence).\n\tcondition := strings.TrimSpace(sentence)\n\n\t// Load existing conditions (if file exists).\n\tvar conditions []string\n\tif _, err := os.Stat(automaticApprovalFile); os.IsNotExist(err) {\n\t\tconditions = []string{}\n\t} else {\n\t\traw, err := os.ReadFile(automaticApprovalFile)\n\t\tif err != nil {\n\t\t\treturn \u0026mcp.CallToolResult{\n\t\t\t\tContent: []mcp.Content{\n\t\t\t\t\tmcp.TextContent{\n\t\t\t\t\t\tType: \"text\",\n\t\t\t\t\t\tText: fmt.Sprintf(\"Error reading automatic approval file: %v\", err),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t}\n\t\tif err := json.Unmarshal(raw, \u0026conditions); err != nil {\n\t\t\treturn \u0026mcp.CallToolResult{\n\t\t\t\tContent: []mcp.Content{\n\t\t\t\t\tmcp.TextContent{\n\t\t\t\t\t\tType: \"text\",\n\t\t\t\t\t\tText: fmt.Sprintf(\"Error unmarshalling automatic approval file: %v\", err),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t}\n\t}\n\n\t// Append the new condition.\n\tconditions = append(conditions, condition)\n\n\t// Marshal the updated conditions.\n\tupdatedRaw, err := json.MarshalIndent(conditions, \"\", \"  \")\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error marshalling updated conditions: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Ensure the directory exists.\n\tapprovalDir := filepath.Dir(automaticApprovalFile)\n\tif err := os.MkdirAll(approvalDir, fs.ModePerm); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error creating directory for automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Write the updated file.\n\tif err := os.WriteFile(automaticApprovalFile, updatedRaw, 0644); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error writing automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"Condition added successfully: %s\", condition),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// Tool: List Automatic Approval Conditions\n//\n// This tool retrieves and returns the list of conditions from the automatic_approval.json file.\nfunc handleListApprovalConditionsTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\tvar conditions []string\n\n\tif _, err := os.Stat(automaticApprovalFile); os.IsNotExist(err) {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"No automatic approval conditions found.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\traw, err := os.ReadFile(automaticApprovalFile)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error reading automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tif err := json.Unmarshal(raw, \u0026conditions); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error unmarshalling automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Format the list as a pretty JSON string.\n\tformatted, err := json.MarshalIndent(conditions, \"\", \"  \")\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error formatting conditions: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: string(formatted),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// Tool: Remove Automatic Approval Condition\n//\n// This tool removes a specific condition from the automatic_approval.json file.\n// Input parameter: \"condition\" (the exact text of the condition to remove).\nfunc handleRemoveApprovalConditionTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\targs := request.Params.Arguments\n\tconditionToRemove, ok := args[\"condition\"].(string)\n\tif !ok || strings.TrimSpace(conditionToRemove) == \"\" {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"'condition' parameter is required\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tconditionToRemove = strings.TrimSpace(conditionToRemove)\n\tvar conditions []string\n\n\tif _, err := os.Stat(automaticApprovalFile); os.IsNotExist(err) {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"No automatic approval conditions found.\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\traw, err := os.ReadFile(automaticApprovalFile)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error reading automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tif err := json.Unmarshal(raw, \u0026conditions); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error unmarshalling automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Remove the specified condition.\n\tfound := false\n\tnewConditions := []string{}\n\tfor _, cond := range conditions {\n\t\tif cond == conditionToRemove {\n\t\t\tfound = true\n\t\t\tcontinue\n\t\t}\n\t\tnewConditions = append(newConditions, cond)\n\t}\n\n\tif !found {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Condition '%s' not found.\", conditionToRemove),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Marshal and write the updated list back to the file.\n\tupdatedRaw, err := json.MarshalIndent(newConditions, \"\", \"  \")\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error marshalling updated conditions: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tapprovalDir := filepath.Dir(automaticApprovalFile)\n\tif err := os.MkdirAll(approvalDir, fs.ModePerm); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error creating directory for automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tif err := os.WriteFile(automaticApprovalFile, updatedRaw, 0644); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error writing automatic approval file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"Condition '%s' removed successfully.\", conditionToRemove),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\nfunc handleSaveAnswerTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\t// Retrieve and validate input parameters.\n\targs := request.Params.Arguments\n\n\tqueryID, ok := args[\"query\"].(string)\n\tif !ok || strings.TrimSpace(queryID) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'query' parameter is required\")\n\t}\n\tfrom, ok := args[\"from\"].(string)\n\tif !ok || strings.TrimSpace(from) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'from' parameter is required\")\n\t}\n\tanswer, ok := args[\"answer\"].(string)\n\tif !ok || strings.TrimSpace(answer) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'answer' parameter is required\")\n\t}\n\n\t// Load existing answers from the file.\n\tvar answersData map[string]map[string]string\n\tif _, err := os.Stat(anwsersFile); os.IsNotExist(err) {\n\t\t// File doesn't exist; initialize a new map.\n\t\tanswersData = make(map[string]map[string]string)\n\t} else {\n\t\traw, err := os.ReadFile(anwsersFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to read answers file: %w\", err)\n\t\t}\n\t\tif err := json.Unmarshal(raw, \u0026answersData); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal answers file: %w\", err)\n\t\t}\n\t}\n\n\t// Check if the query_id exists. If not, create a new entry.\n\tif answersData[queryID] == nil {\n\t\tanswersData[queryID] = make(map[string]string)\n\t}\n\n\t// Append (or update) the new answer using both the 'from' and 'to' keys.\n\tanswersData[queryID][from] = answer\n\n\t// Marshal the updated answersData back to JSON.\n\tupdatedRaw, err := json.MarshalIndent(answersData, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal answers data: %w\", err)\n\t}\n\n\t// Ensure the directory exists (using the same pattern as in saveQueries).\n\tanswersDir := filepath.Dir(anwsersFile)\n\tif err := os.MkdirAll(answersDir, fs.ModePerm); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create directory %s: %w\", answersDir, err)\n\t}\n\n\t// Write the updated JSON back to the file.\n\tif err := os.WriteFile(anwsersFile, updatedRaw, 0644); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write answers file: %w\", err)\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"Answer updated successfully for query: %s\", queryID),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// Tool: Manage Answer for Query\n//\n// This tool manages answers for a given query. It expects the following parameters:\n//   - query_id: The ID of the query.\n//   - from: The sender identifier.\n//   - to: The recipient identifier.\n//   - answer: The answer text.\n//\n// The answers.json file is structured as follows:\n//\n//\t{\n//\t  \"\u003cquery_id\u003e\": {\n//\t    \"\u003cfrom\u003e\": \"\u003canswer_value\u003e\",\n//\t    \"\u003cto\u003e\": \"\u003canswer_value\u003e\"\n//\t  }\n//\t}\nfunc handleSendAnswerTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\t// Retrieve and validate input parameters.\n\targs := request.Params.Arguments\n\n\tqueryID, ok := args[\"query\"].(string)\n\tif !ok || strings.TrimSpace(queryID) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'query' parameter is required\")\n\t}\n\tfrom, ok := args[\"from\"].(string)\n\tif !ok || strings.TrimSpace(from) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'from' parameter is required\")\n\t}\n\t// to, ok := args[\"to\"].(string)\n\t// if !ok || strings.TrimSpace(to) == \"\" {\n\t// \treturn nil, fmt.Errorf(\"'to' parameter is required\")\n\t// }\n\tanswer, ok := args[\"answer\"].(string)\n\tif !ok || strings.TrimSpace(answer) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'answer' parameter is required\")\n\t}\n\n\t// Load existing answers from the file.\n\tvar answersData map[string]map[string]string\n\tif _, err := os.Stat(anwsersFile); os.IsNotExist(err) {\n\t\t// File doesn't exist; initialize a new map.\n\t\tanswersData = make(map[string]map[string]string)\n\t} else {\n\t\traw, err := os.ReadFile(anwsersFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to read answers file: %w\", err)\n\t\t}\n\t\tif err := json.Unmarshal(raw, \u0026answersData); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal answers file: %w\", err)\n\t\t}\n\t}\n\n\t// Check if the query_id exists. If not, create a new entry.\n\tif answersData[queryID] == nil {\n\t\tanswersData[queryID] = make(map[string]string)\n\t}\n\n\t// Append (or update) the new answer using both the 'from' and 'to' keys.\n\tanswersData[queryID][from] = answer\n\n\t// Marshal the updated answersData back to JSON.\n\tupdatedRaw, err := json.MarshalIndent(answersData, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal answers data: %w\", err)\n\t}\n\n\t// Ensure the directory exists (using the same pattern as in saveQueries).\n\tanswersDir := filepath.Dir(anwsersFile)\n\tif err := os.MkdirAll(answersDir, fs.ModePerm); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create directory %s: %w\", answersDir, err)\n\t}\n\n\t// Write the updated JSON back to the file.\n\tif err := os.WriteFile(anwsersFile, updatedRaw, 0644); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write answers file: %w\", err)\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"Answer updated successfully for query: %s\", queryID),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// Tool: Get Answers for Query\n//\n// This tool retrieves all answers associated with a given answer_id.\n// The answers.json file is expected to have the following structure:\n//\n//\t{\n//\t  \"\u003cquery_id\u003e\": {\n//\t    \"\u003cfrom\u003e\": \"\u003canswer_value\u003e\",\n//\t    \"\u003cto\u003e\": \"\u003canswer_value\u003e\"\n//\t  }\n//\t}\n//\n// Given an answer_id, this tool will load the file, check if the entry exists,\n// and return the associated answers. In case of any error, the error message\n// will be returned in the Text field of the CallToolResult.\nfunc handleGetAnswersTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\t// Retrieve and validate input parameter.\n\targs := request.Params.Arguments\n\tqueryId, ok := args[\"query\"].(string)\n\tif !ok || strings.TrimSpace(queryId) == \"\" {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"'query_id' parameter is required\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Load existing answers from the file.\n\tvar answersData map[string]map[string]string\n\tif _, err := os.Stat(anwsersFile); os.IsNotExist(err) {\n\t\t// File doesn't exist; therefore, no answers can be found.\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"No answers found for id: %s\", queryId),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t} else {\n\t\traw, err := os.ReadFile(anwsersFile)\n\t\tif err != nil {\n\t\t\treturn \u0026mcp.CallToolResult{\n\t\t\t\tContent: []mcp.Content{\n\t\t\t\t\tmcp.TextContent{\n\t\t\t\t\t\tType: \"text\",\n\t\t\t\t\t\tText: fmt.Sprintf(\"Error reading answers file: %v\", err),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t}\n\t\tif err := json.Unmarshal(raw, \u0026answersData); err != nil {\n\t\t\treturn \u0026mcp.CallToolResult{\n\t\t\t\tContent: []mcp.Content{\n\t\t\t\t\tmcp.TextContent{\n\t\t\t\t\t\tType: \"text\",\n\t\t\t\t\t\tText: fmt.Sprintf(\"Error unmarshalling answers file: %v\", err),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t}\n\t}\n\n\t// Check if the answer_id exists in the loaded data.\n\tif answers, exists := answersData[queryId]; exists {\n\t\t// Format the answers as a pretty JSON string.\n\t\tformatted, err := json.MarshalIndent(answers, \"\", \"  \")\n\t\tif err != nil {\n\t\t\treturn \u0026mcp.CallToolResult{\n\t\t\t\tContent: []mcp.Content{\n\t\t\t\t\tmcp.TextContent{\n\t\t\t\t\t\tType: \"text\",\n\t\t\t\t\t\tText: fmt.Sprintf(\"Error formatting answer data: %v\", err),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t}\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: string(formatted),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// If answer_id is not found, return a message indicating so.\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"No answers found for id: %s\", queryId),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// -----------------------------------------------------------------------------\n// MCP Tool Handlers for Query Management\n// -----------------------------------------------------------------------------\n\n// Tool: Ask New Query\n//\n// Creates a new query. It requires a \"question\" argument and uses the userOrigin as the \"from\" field.\n// It mocks document retrieval and answer generation, saves the new query with status \"accepted\",\n// and returns the generated answer.\n//\n// Example usage:\n//\n//\t{\n//\t  \"tool\": \"cqAskNewQuery\",\n//\t  \"arguments\": {\n//\t      \"question\": \"What is the capital of France?\"\n//\t  }\n//\t}\nfunc handleAskNewQueryTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\topenaiClient := openai.NewClient(\"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\")\n\ts := server.ServerFromContext(ctx)\n\n\targs := request.Params.Arguments\n\tquestion, ok := args[\"question\"].(string)\n\tif !ok || strings.TrimSpace(question) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'question' parameter is required\")\n\t}\n\tuserOrigin := request.Params.Meta.Origin\n\n\t// Mock RAG: Retrieve relevant documents.\n\t// docs := mockRetrieveDocuments(question)\n\tdocs, err := retrieveDocuments(ctx, question, 3)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error retrieving documents: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\tanswer, err := generateAnswer(ctx, openaiClient, question, docs)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error generating answer: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Generate new query ID.\n\tnewID, err := generateQueryID()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to generate query ID: %w\", err)\n\t}\n\n\t// Load existing queries.\n\tqueriesData, err := loadQueries()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif queriesData.Queries == nil {\n\t\tqueriesData.Queries = make(map[string]Query)\n\t}\n\n\tvar docFilenames []string = []string{}\n\tfor _, doc := range docs {\n\t\tdocFilenames = append(docFilenames, doc.FileName)\n\t}\n\n\t// Create new query.\n\tnewQuery := Query{\n\t\tID:               newID,\n\t\tFrom:             userOrigin,\n\t\tQuestion:         question,\n\t\tAnswer:           answer,\n\t\tDocumentsRelated: docFilenames,\n\t\tStatus:           \"pending\",\n\t}\n\treason, automaticApproval := checkAutomaticApprovalConditions(ctx, answer, newQuery, openaiClient)\n\tif automaticApproval {\n\t\tnewQuery.Status = \"accepted\"\n\t}\n  newQuery.Reason = reason\n\tqueriesData.Queries[newID] = newQuery\n\n\t// Save queries.\n\tif err := saveQueries(queriesData); err != nil {\n\t\treturn nil, err\n\t}\n\tif automaticApproval {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"%s's Answer: %s\", s.Id, answer),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t} else {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Query created successfully with ID: %s\\n\", newID),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n}\n\n// Tool: List Queries\n//\nfunc handleListQueriesTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\t// Load all queries from the file.\n\tqueriesData, err := loadQueries()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Retrieve optional filter parameters.\n\targs := request.Params.Arguments\n\tvar statusFilter string\n\tvar fromFilter string\n\n\t// Use \"status\" filter if provided.\n\tif statusVal, ok := args[\"status\"].(string); ok \u0026\u0026 strings.TrimSpace(statusVal) != \"\" {\n\t\tstatusFilter = strings.ToLower(strings.TrimSpace(statusVal))\n\t}\n\t// Use \"from\" filter if provided.\n\tif fromVal, ok := args[\"from\"].(string); ok \u0026\u0026 strings.TrimSpace(fromVal) != \"\" {\n\t\tfromFilter = strings.TrimSpace(fromVal)\n\t}\n\n\t// If no filters are provided, return the complete list.\n\tif statusFilter == \"\" \u0026\u0026 fromFilter == \"\" {\n\t\toutput, err := json.MarshalIndent(queriesData.Queries, \"\", \"  \")\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to marshal queries: %w\", err)\n\t\t}\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: string(output),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Filter queries based on provided optional parameters.\n\tfiltered := make(map[string]Query)\n\tfor id, qry := range queriesData.Queries {\n\t\t// Apply status filter if set.\n\t\tif statusFilter != \"\" {\n\t\t\tif strings.ToLower(qry.Status) != statusFilter {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\t// Apply from filter if set.\n\t\tif fromFilter != \"\" {\n\t\t\tif qry.From != fromFilter {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tfiltered[id] = qry\n\t}\n\n\t// Marshal the filtered queries into a pretty JSON string.\n\toutput, err := json.MarshalIndent(filtered, \"\", \"  \")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal filtered queries: %w\", err)\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: string(output),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n\nfunc handleAcceptQueryTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\targs := request.Params.Arguments\n\ts := server.ServerFromContext(ctx)\n\n\tid, ok := args[\"id\"].(string)\n\tif !ok || strings.TrimSpace(id) == \"\" {\n\t\treturn nil, fmt.Errorf(\"'id' parameter is required\")\n\t}\n\n\tqueriesData, err := loadQueries()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tqry, exists := queriesData.Queries[id]\n\tif !exists {\n\t\treturn nil, fmt.Errorf(\"query with ID '%s' not found\", id)\n\t}\n\n\t// Update status to \"accepted\" if not already.\n\tqry.Status = \"accepted\"\n\tqueriesData.Queries[id] = qry\n\n\tif err := saveQueries(queriesData); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"Question '%s' has been accepted.\\n Calling cqSendAnswer tool. Sending answer to @%s from %s answer: %s\", qry.Question, qry.From, s.Id, qry.Answer),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// -----------------------------------------------------------------------------\n// MCP Server: Registering Tools for Query Management\n// -----------------------------------------------------------------------------\n\nfunc NewMCPQueryServer() *server.MCPServer {\n\tmcpServer := server.NewMCPServer(\n\t\t\"example-servers/queries\",\n\t\t\"1.0.0\",\n\t\tserver.WithResourceCapabilities(true, true),\n\t\tserver.WithPromptCapabilities(true),\n\t\tserver.WithLogging(),\n\t)\n\n\t// Tool: Ask New Query\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqAskNewQuery\",\n\t\t\tmcp.WithDescription(\"Creates a new query using a question. It retrieves related documents, generates an answer, and saves the query with status 'accepted'.\"),\n\t\t\tmcp.WithString(\"question\", mcp.Description(\"The question for the query\"), mcp.Required()),\n\t\t\tmcp.WithPeer(),\n\t\t),\n\t\thandleAskNewQueryTool,\n\t)\n\n\t// Tool: Manage Answer\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqSendAnswer\",\n\t\t\tmcp.WithDescription(\"Sends an answer to a query.\"),\n\t\t\tmcp.WithString(\"query\", mcp.Description(\"Question made in the query\"), mcp.Required()),\n\t\t\tmcp.WithString(\"from\", mcp.Description(\"Sender of the answer\"), mcp.Required()),\n\t\t\tmcp.WithString(\"answer\", mcp.Description(\"The answer text\"), mcp.Required()),\n\t\t\tmcp.WithPeer(),\n\t\t),\n\t\thandleSendAnswerTool,\n\t)\n\n\t// mcpServer.AddTool(\n\t// \tmcp.NewTool(\"cqSavesAnswer\",\n\t// \t\tmcp.WithDescription(\"Saves an answer to a query.\"),\n\t// \t\tmcp.WithString(\"query\", mcp.Description(\"Question made in the query\"), mcp.Required()),\n\t// \t\tmcp.WithString(\"from\", mcp.Description(\"Sender of the answer\"), mcp.Required()),\n\t// \t\tmcp.WithString(\"answer\", mcp.Description(\"The answer text\"), mcp.Required()),\n\t// \t),\n\t// \thandleSaveAnswerTool,\n\t// )\n\n  // Tool: List Queries\n  mcpServer.AddTool(\n    mcp.NewTool(\"cqListQueries\",\n      mcp.WithDescription(\"Lists all queries.\"),\n      mcp.WithString(\"status\", mcp.Description(\"Filter by status (optional)\")),\n      mcp.WithString(\"from\", mcp.Description(\"Filter by sender (optional)\")),\n    ),\n    handleListQueriesTool,\n  )\n\n\t// Tool: Get Answers\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqGetAnswer\",\n\t\t\tmcp.WithDescription(\"Retrieves answer for a given query question.\"),\n\t\t\tmcp.WithString(\"query\", mcp.Description(\"Question of the query to retrieve answers for\"), mcp.Required()),\n\t\t),\n\t\thandleGetAnswersTool,\n\t)\n\n\t// Tool: Accept Query\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqAcceptQuery\",\n\t\t\tmcp.WithDescription(\"Accepts a pending query by updating its status to 'accepted'.\"),\n\t\t\tmcp.WithString(\"id\", mcp.Description(\"ID of the query to accept\"), mcp.Required()),\n\t\t),\n\t\thandleAcceptQueryTool,\n\t)\n\n\t// Tool: Add Automatic Approval Condition\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqAddAutoApprovalCondition\",\n\t\t\tmcp.WithDescription(\"Extracts a condition from a sentence and appends it to automatic_approval.json.\"),\n\t\t\tmcp.WithString(\"sentence\", mcp.Description(\"Sentence containing the condition\"), mcp.Required()),\n\t\t),\n\t\thandleAddApprovalConditionTool,\n\t)\n\n\t// Tool: List Automatic Approval Conditions\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqListAutoApprovalConditions\",\n\t\t\tmcp.WithDescription(\"Lists all automatic approval conditions from automatic_approval.json.\"),\n\t\t\tmcp.WithBoolean(\"flag\", mcp.DefaultBool(false), mcp.Description(\"Ignore this parameter\")),\n\t\t),\n\t\thandleListApprovalConditionsTool,\n\t)\n\n\t// Tool: Remove Automatic Approval Condition\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqRemoveAutoApprovalCondition\",\n\t\t\tmcp.WithDescription(\"Removes a specific condition from automatic_approval.json.\"),\n\t\t\tmcp.WithString(\"condition\", mcp.Description(\"The condition text to remove\"), mcp.Required()),\n\t\t),\n\t\thandleRemoveApprovalConditionTool,\n\t)\n\n\t// -------------------------------------------------------------------------\n\t// New Tool Registration: Add RAG Resource\n\t// -------------------------------------------------------------------------\n\tmcpServer.AddTool(\n\t\tmcp.NewTool(\"cqUpdateRagKnowledgeBase\",\n\t\t\tmcp.WithDescription(\"Adds a new RAG resource by loading a file's content, appending it to the rag_sources file, and refreshing the vector database.\"),\n\t\t\tmcp.WithString(\"file_path\", mcp.Description(\"Path to the file to add as a RAG resource\"), mcp.Required()),\n\t\t),\n\t\thandleAddRagResourceTool,\n\t)\n\n\treturn mcpServer\n}\n\nfunc setupChromemCollection(vectorPath string) *chromem.Collection {\n\t// Setup chromem-go\n\tdb, err := chromem.NewPersistentDB(vectorPath, false)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tembeddingModel := \"nomic-embed-text\"\n\n\t// Create collection if it wasn't loaded from persistent storage yet.\n\t// You can pass nil as embedding function to use the default (OpenAI text-embedding-3-small),\n\t// which is very good and cheap. It would require the OPENAI_API_KEY environment\n\t// variable to be set.\n\t// For this example we choose to use a locally running embedding model though.\n\t// It requires Ollama to serve its API at \"http://localhost:11434/api\".\n\tcollection, err := db.GetOrCreateCollection(\"Wikipedia\", nil, chromem.NewEmbeddingFuncOllama(embeddingModel, \"\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn collection\n}\n\nfunc feedChromem(ctx context.Context, sourcePath string, update bool) {\n\t// Feed chromem with documents\n\tvar docs []chromem.Document\n\tif chromemCollection.Count() == 0  || update {\n\t\t// Here we use a DBpedia sample, where each line contains the lead section/introduction\n\t\t// to some Wikipedia article and its category.\n\t\tf, err := os.Open(sourcePath)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdefer f.Close()\n\t\td := json.NewDecoder(f)\n\t\tfor i := 1; ; i++ {\n\t\t\tvar article struct {\n\t\t\t\tText     string `json:\"text\"`\n\t\t\t\tFileName string `json:\"file\"`\n\t\t\t}\n\t\t\terr := d.Decode(\u0026article)\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t} else if err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\n\t\t\t// The embeddings model we use in this example (\"nomic-embed-text\")\n\t\t\t// fare better with a prefix to differentiate between document and query.\n\t\t\t// We'll have to cut it off later when we retrieve the documents.\n\t\t\t// An alternative is to create the embedding with `chromem.NewDocument()`,\n\t\t\t// and then change back the content before adding it do the collection\n\t\t\t// with `collection.AddDocument()`.\n\t\t\tcontent := \"search_document: \" + article.Text\n\n\t\t\tdocs = append(docs, chromem.Document{\n\t\t\t\tID:       strconv.Itoa(i),\n\t\t\t\tMetadata: map[string]string{\"file\": article.FileName},\n\t\t\t\tContent:  content,\n\t\t\t})\n\t\t}\n\t\tlog.Println(\"Adding documents to chromem-go, including creating their embeddings via Ollama API...\")\n\t\terr = chromemCollection.AddDocuments(ctx, docs, runtime.NumCPU())\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t} else {\n\t\tlog.Println(\"Not reading JSON lines because collection was loaded from persistent storage.\")\n\t}\n}\n\n// -----------------------------------------------------------------------------\n// Tool: Add RAG Resource\n//\n// This tool accepts a file path as input, reads the file content, and appends a new\n// RAG resource to the rag_sources file. The expected structure for each RAG resource\n// is: {\"file\": \u003cfilename\u003e, \"text\": \u003ctext\u003e}\n// After updating the file, it refreshes the vector database by invoking feedChromem.\n//\n// Example usage:\n//\n//\t{\n//\t  \"tool\": \"cqAddRagResource\",\n//\t  \"arguments\": {\n//\t    \"file_path\": \"/path/to/resource.txt\"\n//\t  }\n//\t}\nfunc handleAddRagResourceTool(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {\n\t// Retrieve the file_path parameter.\n\targs := request.Params.Arguments\n\tfilePath, ok := args[\"file_path\"].(string)\n\tif !ok || strings.TrimSpace(filePath) == \"\" {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: \"'file_path' parameter is required\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Read the content from the specified file.\n\tdata, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error reading file at '%s': %v\", filePath, err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Extract the base filename.\n\tbaseFile := filepath.Base(filePath)\n\n\t// Create a new RAG resource object.\n\tresource := map[string]string{\n\t\t\"file\": baseFile,\n\t\t\"text\": string(data),\n\t}\n\n\t// Marshal the resource to JSON.\n\tresourceJSON, err := json.Marshal(resource)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error marshalling resource: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Open the RAG sources file (sourcePath) in append mode.\n\tf, err := os.OpenFile(sourcePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error opening RAG sources file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\tdefer f.Close()\n\n\t// Write the JSON object as a new line in the file.\n\tif _, err := f.Write(append(resourceJSON, '\\n')); err != nil {\n\t\treturn \u0026mcp.CallToolResult{\n\t\t\tContent: []mcp.Content{\n\t\t\t\tmcp.TextContent{\n\t\t\t\t\tType: \"text\",\n\t\t\t\t\tText: fmt.Sprintf(\"Error writing to RAG sources file: %v\", err),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil\n\t}\n\n\t// Log the successful addition.\n\tlog.Printf(\"Added new RAG resource: %s\", baseFile)\n\n\t// Refresh the vector database by invoking feedChromem.\n\t// Note: feedChromem reads the rag_sources file and adds documents if the collection is empty.\n\tfeedChromem(ctx, sourcePath, true)\n\n\t// Return a success message.\n\treturn \u0026mcp.CallToolResult{\n\t\tContent: []mcp.Content{\n\t\t\tmcp.TextContent{\n\t\t\t\tType: \"text\",\n\t\t\t\tText: fmt.Sprintf(\"RAG resource '%s' added successfully and vector database refreshed.\", baseFile),\n\t\t\t},\n\t\t},\n\t}, nil\n}\n\n// -----------------------------------------------------------------------------\n// Main Function\n// -----------------------------------------------------------------------------\nfunc main() {\n\tvar transport string\n\t// Set the path to the queries JSON file.\n\tflag.StringVar(\u0026queriesFile, \"queriesFile\", \"queries.json\", \"Path to the queries JSON file\")\n\tflag.StringVar(\u0026anwsersFile, \"answersFile\", \"answers.json\", \"Path to the answers JSON file\")\n\tflag.StringVar(\u0026automaticApprovalFile, \"automaticApproval\", \"automatic_approval.json\", \"Path to the automatic_approval JSON file\")\n\tflag.StringVar(\u0026vectorPath, \"vector_db\", \"/home/ubuntu/workspace/mrcp/mcp-go/examples/survey_server/vector_db\", \"Path to the queries JSON file\")\n\tflag.StringVar(\u0026sourcePath, \"rag_sources\", \"/home/ubuntu/workspace/mrcp/mcp-go/examples/survey_server/rag_sources.jsonl\", \"Path to the queries JSON file\")\n\tflag.Parse()\n\n\tlog.Printf(\"Using queries file: %s\", queriesFile)\n\n\tctx := context.Background()\n\tchromemCollection = setupChromemCollection(vectorPath)\n\tfeedChromem(ctx, sourcePath, false)\n\n\tlog.Println(\"Finished!\")\n\n\tmcpServer := NewMCPQueryServer()\n\n\tif transport == \"sse\" {\n\t\tsseServer := server.NewSSEServer(mcpServer, server.WithBaseURL(\"http://localhost:8080\"))\n\t\tlog.Printf(\"SSE server listening on :8080\")\n\t\tif err := sseServer.Start(\":8080\"); err != nil {\n\t\t\tlog.Fatalf(\"Server error: %v\", err)\n\t\t}\n\t} else {\n\t\tif err := server.ServeStdio(mcpServer); err != nil {\n\t\t\tlog.Fatalf(\"Server error: %v\", err)\n\t\t}\n\t}\n}\n"}

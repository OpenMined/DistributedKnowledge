; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

#define MyAppName "Distributed Knowledge"
#define MyAppVersion "0.1.0"
#define MyAppPublisher "OpenMined"
#define MyAppURL "https://distributedknowledge.org/"
#define MyAppExeName "dk.exe"

[Setup]
; NOTE: The value of AppId uniquely identifies this application. Do not use the same AppId value in installers for other applications.
; (To generate a new GUID, click Tools | Generate GUID inside the IDE.)
AppId={{98E5E777-12E7-4762-95BE-ECA0FCF3B1F5}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
;AppVerName={#MyAppName} {#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
SetupIconFile=".\favicon.ico"
WizardImageFile=".\dk_logo.bmp"
DefaultDirName={localappdata}\{#MyAppName}
UninstallDisplayIcon={app}\{#MyAppExeName}
; "ArchitecturesAllowed=x64compatible" specifies that Setup cannot run
; on anything but x64 and Windows 11 on Arm.
ArchitecturesAllowed=x64compatible
; "ArchitecturesInstallIn64BitMode=x64compatible" requests that the
; install be done in "64-bit mode" on x64 or Windows 11 on Arm,
; meaning it should use the native 64-bit Program Files directory and
; the 64-bit view of the registry.
ArchitecturesInstallIn64BitMode=x64compatible
DefaultGroupName={#MyAppName}
DisableProgramGroupPage=yes
; LicenseFile=MIT License
; Uncomment the following line to run in non administrative install mode (install for current user only.)
PrivilegesRequired=lowest
OutputDir=.\
OutputBaseFilename=dk_installer
SolidCompression=yes
WizardStyle=modern

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"
Name: "arabic"; MessagesFile: "compiler:Languages\Arabic.isl"
Name: "armenian"; MessagesFile: "compiler:Languages\Armenian.isl"
Name: "brazilianportuguese"; MessagesFile: "compiler:Languages\BrazilianPortuguese.isl"
Name: "bulgarian"; MessagesFile: "compiler:Languages\Bulgarian.isl"
Name: "catalan"; MessagesFile: "compiler:Languages\Catalan.isl"
Name: "corsican"; MessagesFile: "compiler:Languages\Corsican.isl"
Name: "czech"; MessagesFile: "compiler:Languages\Czech.isl"
Name: "danish"; MessagesFile: "compiler:Languages\Danish.isl"
Name: "dutch"; MessagesFile: "compiler:Languages\Dutch.isl"
Name: "finnish"; MessagesFile: "compiler:Languages\Finnish.isl"
Name: "french"; MessagesFile: "compiler:Languages\French.isl"
Name: "german"; MessagesFile: "compiler:Languages\German.isl"
Name: "hebrew"; MessagesFile: "compiler:Languages\Hebrew.isl"
Name: "hungarian"; MessagesFile: "compiler:Languages\Hungarian.isl"
Name: "icelandic"; MessagesFile: "compiler:Languages\Icelandic.isl"
Name: "italian"; MessagesFile: "compiler:Languages\Italian.isl"
Name: "japanese"; MessagesFile: "compiler:Languages\Japanese.isl"
Name: "korean"; MessagesFile: "compiler:Languages\Korean.isl"
Name: "norwegian"; MessagesFile: "compiler:Languages\Norwegian.isl"
Name: "polish"; MessagesFile: "compiler:Languages\Polish.isl"
Name: "portuguese"; MessagesFile: "compiler:Languages\Portuguese.isl"
Name: "russian"; MessagesFile: "compiler:Languages\Russian.isl"
Name: "slovak"; MessagesFile: "compiler:Languages\Slovak.isl"
Name: "slovenian"; MessagesFile: "compiler:Languages\Slovenian.isl"
Name: "spanish"; MessagesFile: "compiler:Languages\Spanish.isl"
Name: "swedish"; MessagesFile: "compiler:Languages\Swedish.isl"
Name: "tamil"; MessagesFile: "compiler:Languages\Tamil.isl"
Name: "turkish"; MessagesFile: "compiler:Languages\Turkish.isl"
Name: "ukrainian"; MessagesFile: "compiler:Languages\Ukrainian.isl"

[Types]
Name: "full"; Description: "Full installation"

[Components]
Name: "program"; Description: "Program Files"; Types: full; Flags: fixed

[Files]
Source: "..\{#MyAppExeName}"; DestDir: "{app}"; Flags: ignoreversion
; NOTE: Don't use "Flags: ignoreversion" on any shared system files

[Icons]
Name: "{group}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"

[Dirs]
Name: "{app}\keys"; Flags: uninsneveruninstall

[Code]
var
  MCPJsonPathPage: TInputFileWizardPage;
  UserConfigPage: TInputQueryWizardPage;
  LLMSelectionPage: TInputOptionWizardPage;
  ModelSelectionPage: TInputOptionWizardPage;
  ApiKeyPage: TInputQueryWizardPage;
  MCPJsonPath: String;
  UserID: String;
  SelectedLLMProvider: String;
  SelectedModel: String;
  ApiKey: String;

// Helper function to escape backslashes for JSON
function EscapeBackslashes(const S: String): String;
var
  i: Integer;
begin
  Result := '';
  for i := 1 to Length(S) do
  begin
    if S[i] = '\' then
      Result := Result + '\\'
    else
      Result := Result + S[i];
  end;
end;

// Helper function to write debug logs
procedure DebugLog(const Message: String);
begin
  Log(Message);
  // You can also write to a log file if needed
  // SaveStringToFile(ExpandConstant('{app}\install.log'), Message + #13#10, True);
end;

// Create keys directory but don't generate any files
procedure SetupKeysDir(const KeysDir: String);
begin
  DebugLog('Setting up keys directory: ' + KeysDir);
  
  // Just log the directory creation, actual creation is handled by ForceDirectories elsewhere
  DebugLog('Keys directory is ready at: ' + KeysDir);
end;

// Create model_config.json file
procedure CreateModelConfigJson(const InstallDir: String);
var
  ModelConfigPath: String;
  JsonContent: String;
begin
  ModelConfigPath := InstallDir + '\model_config.json';
  DebugLog('Creating model_config.json at: ' + ModelConfigPath);
  
  // Base JSON structure based on provider type
  if (SelectedLLMProvider = 'openai') or (SelectedLLMProvider = 'anthropic') then
  begin
    JsonContent := '{' + #13#10;
    JsonContent := JsonContent + '  "provider": "' + SelectedLLMProvider + '",' + #13#10;
    JsonContent := JsonContent + '  "api_key": "' + ApiKey + '",' + #13#10;
    JsonContent := JsonContent + '  "model": "' + SelectedModel + '",' + #13#10;
    JsonContent := JsonContent + '  "parameters": {' + #13#10;
    JsonContent := JsonContent + '    "temperature": 0.7,' + #13#10;
    JsonContent := JsonContent + '    "max_tokens": 1000' + #13#10;
    JsonContent := JsonContent + '  }' + #13#10;
    JsonContent := JsonContent + '}';
  end
  else if SelectedLLMProvider = 'ollama' then
  begin
    JsonContent := '{' + #13#10;
    JsonContent := JsonContent + '  "provider": "' + SelectedLLMProvider + '",' + #13#10;
    JsonContent := JsonContent + '  "model": "' + SelectedModel + '",' + #13#10;
    JsonContent := JsonContent + '  "base_url": "http://localhost:11434/api/generate",' + #13#10;
    JsonContent := JsonContent + '  "parameters": {' + #13#10;
    JsonContent := JsonContent + '    "temperature": 0.7,' + #13#10;
    JsonContent := JsonContent + '    "max_tokens": 1000' + #13#10;
    JsonContent := JsonContent + '  }' + #13#10;
    JsonContent := JsonContent + '}';
  end;
  
  DebugLog('Generated model_config.json content: ' + JsonContent);
  
  // Write the model_config.json file
  if SaveStringToFile(ModelConfigPath, JsonContent, False) then
    DebugLog('Successfully wrote model_config.json file: ' + ModelConfigPath)
  else
    DebugLog('ERROR: Failed to write model_config.json file: ' + ModelConfigPath);
end;


// Handle MCP JSON file operations (without LLM info)
procedure ProcessMCPJsonFile(const JsonPath: String; const InstallDir: String; const UserId: String);
var
  JsonContent, NewEntry, KeysDir, RagSourcesPath: String;
  CommandPath: String;
begin
  DebugLog('Processing MCP JSON file: ' + JsonPath);
  
  KeysDir := InstallDir + '\keys';
  CommandPath := InstallDir + '\' + ExpandConstant('{#MyAppExeName}');
  RagSourcesPath := InstallDir + '\rag_sources.jsonl';
   
  // Create the JSON entry one piece at a time with proper string escaping
  NewEntry := '{"command": "' + EscapeBackslashes(CommandPath) + '",';
  NewEntry := NewEntry + '"args": [';
  NewEntry := NewEntry + '"-userId", "' + UserId + '",';
  NewEntry := NewEntry + '"-private", "' + EscapeBackslashes(KeysDir + '\private_key') + '",';
  NewEntry := NewEntry + '"-public", "' + EscapeBackslashes(KeysDir + '\public_key') + '",';
  NewEntry := NewEntry + '"-project_path", "' + EscapeBackslashes(InstallDir) + '",';
  NewEntry := NewEntry + '"-rag_sources", "' + EscapeBackslashes(RagSourcesPath) + '",';
  NewEntry := NewEntry + '"-server", "https://distributedknowledge.org"';
  
  // Complete the args array
  NewEntry := NewEntry + ']}';
  
  // Create the complete JSON structure 
  JsonContent := '{"mcpServers":{"DistributedKnowledge":' + NewEntry + '}}';
  
  DebugLog('Generated JSON content: ' + JsonContent);
  
  // Check if directory exists, create if not
  if not DirExists(ExtractFilePath(JsonPath)) then
  begin
    DebugLog('Creating directory for MCP JSON: ' + ExtractFilePath(JsonPath));
    if not ForceDirectories(ExtractFilePath(JsonPath)) then
      DebugLog('ERROR: Failed to create directory: ' + ExtractFilePath(JsonPath));
  end;
  
  // Write the JSON file
  if SaveStringToFile(JsonPath, JsonContent, False) then
    DebugLog('Successfully wrote MCP JSON file: ' + JsonPath)
  else
    DebugLog('ERROR: Failed to write MCP JSON file: ' + JsonPath);
end;

// Handle MCP JSON file operations (without LLM info)
procedure ProcessMCPsJsonFile(const JsonPath: String; const InstallDir: String; const UserId: String);
var
  JsonContent, NewEntry, KeysDir, RagSourcesPath: String;
  CommandPath: String;
begin
  DebugLog('Processing MCP JSON file: ' + JsonPath);
  
  KeysDir := InstallDir + '\keys';
  CommandPath := InstallDir + '\' + ExpandConstant('{#MyAppExeName}');
  RagSourcesPath := InstallDir + '\rag_sources.jsonl';
  
  // Create empty rag_sources.jsonl file
  if SaveStringToFile(RagSourcesPath, '', False) then
    DebugLog('Created empty rag_sources.jsonl file: ' + RagSourcesPath)
  else
    DebugLog('ERROR: Failed to create rag_sources.jsonl file: ' + RagSourcesPath);
  
  // Create the JSON entry one piece at a time with proper string escaping
  NewEntry := '{"command": "' + EscapeBackslashes(CommandPath) + '",';
  NewEntry := NewEntry + '"args": [';
  NewEntry := NewEntry + '"-userId", "' + UserId + '",';
  NewEntry := NewEntry + '"-private", "' + EscapeBackslashes(KeysDir + '\private_key') + '",';
  NewEntry := NewEntry + '"-public", "' + EscapeBackslashes(KeysDir + '\public_key') + '",';
  NewEntry := NewEntry + '"-project_path", "' + EscapeBackslashes(InstallDir) + '",';
  NewEntry := NewEntry + '"-rag_sources", "' + EscapeBackslashes(RagSourcesPath) + '",';
  NewEntry := NewEntry + '"-server", "https://distributedknowledge.org"';
  
  // Complete the args array
  NewEntry := NewEntry + ']}';
  
  // Create the complete JSON structure 
  JsonContent := '{"mcpServers":{"DistributedKnowledge":' + NewEntry + '}}';
  
  DebugLog('Generated JSON content: ' + JsonContent);
  
  // Check if directory exists, create if not
  if not DirExists(ExtractFilePath(JsonPath)) then
  begin
    DebugLog('Creating directory for MCP JSON: ' + ExtractFilePath(JsonPath));
    if not ForceDirectories(ExtractFilePath(JsonPath)) then
      DebugLog('ERROR: Failed to create directory: ' + ExtractFilePath(JsonPath));
  end;
  
  // Write the JSON file
  if SaveStringToFile(JsonPath, JsonContent, False) then
    DebugLog('Successfully wrote MCP JSON file: ' + JsonPath)
  else
    DebugLog('ERROR: Failed to write MCP JSON file: ' + JsonPath);
end;

procedure InitializeWizard;
begin
  // Create page for specifying mcp.json file path
  MCPJsonPathPage := CreateInputFilePage(wpSelectDir,
    'MCP Configuration File', 'Where is your mcp.json file located?',
    'Select the location of your mcp.json file, or specify where you want to create it:');
  MCPJsonPathPage.Add('MCP JSON file path:', 'JSON files|*.json', '.json');
  
  // Create page for user configuration
  UserConfigPage := CreateInputQueryPage(MCPJsonPathPage.ID,
    'User Information', 'Please provide your user details.',
    'Please enter your User ID:');
  UserConfigPage.Add('User ID:', False);
  
  // Create page for LLM provider selection
  LLMSelectionPage := CreateInputOptionPage(UserConfigPage.ID,
    'LLM Provider Selection', 'Select your LLM provider.',
    'Please choose which LLM provider you want to use:',
    True, False);
  LLMSelectionPage.Add('Anthropic');
  LLMSelectionPage.Add('OpenAI');
  LLMSelectionPage.Add('Ollama');
  LLMSelectionPage.SelectedValueIndex := 0;
  
  // Create page for model selection - using radio buttons instead of a checklist
  ModelSelectionPage := CreateInputOptionPage(LLMSelectionPage.ID,
    'LLM Model Selection', 'Select the specific LLM model.',
    'Please choose which model you want to use:',
    False, False); // Changed to False for exclusive selection (radio buttons)
  
  // Initialize with Anthropic models (since it's the default selection)
  ModelSelectionPage.Add('Claude-Haiku');
  ModelSelectionPage.Add('Claude-Sonnet');
  ModelSelectionPage.SelectedValueIndex := 0;
  
  // Create page for API key
  ApiKeyPage := CreateInputQueryPage(ModelSelectionPage.ID,
    'API Key Configuration', 'Enter your API key.',
    'Please provide your API key for the selected provider:');
  ApiKeyPage.Add('API Key:', True);
  
  // Set default checked values - no need to check items with radio buttons
  ModelSelectionPage.SelectedValueIndex := 0;
end;

function NextButtonClick(CurPageID: Integer): Boolean;
begin
  Result := True;
  
  if CurPageID = LLMSelectionPage.ID then
  begin
    DebugLog('LLM Provider Selection: ' + IntToStr(LLMSelectionPage.SelectedValueIndex));
    
    // First clear the model page
    while ModelSelectionPage.CheckListBox.Items.Count > 0 do
      ModelSelectionPage.CheckListBox.Items.Delete(0);
    
    // Add appropriate models based on the LLM provider selection
    case LLMSelectionPage.SelectedValueIndex of
      0: begin // Anthropic
        ModelSelectionPage.Add('Claude-Haiku');
        ModelSelectionPage.Add('Claude-Sonnet');
        ApiKeyPage.Edits[0].Enabled := True;
        ApiKeyPage.Edits[0].Text := '';
      end;
      1: begin // OpenAI
        ModelSelectionPage.Add('gpt-4o-mini');
        ModelSelectionPage.Add('gpt-4o');
        ApiKeyPage.Edits[0].Enabled := True;
        ApiKeyPage.Edits[0].Text := '';
      end;
      2: begin // Ollama
        ModelSelectionPage.Add('qwen2.5:latest');
        ModelSelectionPage.Add('gemma3:4b');
        ModelSelectionPage.Add('gemma:2b');
        ApiKeyPage.Edits[0].Enabled := False;
        ApiKeyPage.Edits[0].Text := 'Not required for Ollama';
      end;
    end;
    
    // Ensure the first item is selected
    ModelSelectionPage.SelectedValueIndex := 0;
  end;
end;

procedure CurStepChanged(CurStep: TSetupStep);
begin
  if CurStep = ssPostInstall then
  begin
    DebugLog('Running post-installation steps...');
    
    // Collect all the user input
    MCPJsonPath := MCPJsonPathPage.Values[0];
    UserID := UserConfigPage.Values[0];
    
    DebugLog('MCP JSON Path: ' + MCPJsonPath);
    DebugLog('User ID: ' + UserID);
    
    case LLMSelectionPage.SelectedValueIndex of
      0: SelectedLLMProvider := 'anthropic';
      1: SelectedLLMProvider := 'openai';
      2: SelectedLLMProvider := 'ollama';
    end;
    
    DebugLog('Selected LLM Provider: ' + SelectedLLMProvider);
    
    // Get selected model based on provider and selection index
    case LLMSelectionPage.SelectedValueIndex of
      0: begin // Anthropic
        if ModelSelectionPage.SelectedValueIndex = 0 then
          SelectedModel := 'Claude-Haiku'
        else
          SelectedModel := 'Claude-Sonnet';
      end;
      1: begin // OpenAI
        if ModelSelectionPage.SelectedValueIndex = 0 then
          SelectedModel := 'gpt-4o-mini'
        else
          SelectedModel := 'gpt-4o';
      end;
      2: begin // Ollama
        if ModelSelectionPage.SelectedValueIndex = 0 then
          SelectedModel := 'qwen2.5:latest'
        else if ModelSelectionPage.SelectedValueIndex = 1 then
          SelectedModel := 'gemma3:4b'
        else
          SelectedModel := 'gemma:2b';
      end;
    end;
    
    DebugLog('Selected Model: ' + SelectedModel);
    
    ApiKey := ApiKeyPage.Values[0];
    DebugLog('API Key Length: ' + IntToStr(Length(ApiKey)));
    
    // Create keys directory
    if ForceDirectories(ExpandConstant('{app}\keys')) then
      DebugLog('Created keys directory: ' + ExpandConstant('{app}\keys'))
    else
      DebugLog('ERROR: Failed to create keys directory: ' + ExpandConstant('{app}\keys'));
    
    // Set up keys directory (without creating any files)
    SetupKeysDir(ExpandConstant('{app}\keys'));
    
    // Create model_config.json file
    CreateModelConfigJson(ExpandConstant('{app}'));
    
    // Process MCP JSON file
    ProcessMCPJsonFile(MCPJsonPath, ExpandConstant('{app}'), UserID);
    
    DebugLog('Post-installation steps completed.');
  end;
end;

function ShouldSkipPage(PageID: Integer): Boolean;
begin
  Result := False;
  
  // Skip API Key page if Ollama is selected
  if (PageID = ApiKeyPage.ID) and (LLMSelectionPage.SelectedValueIndex = 2) then
    Result := True;
end;

[Run]
Filename: "{app}\{#MyAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: nowait postinstall skipifsilent
